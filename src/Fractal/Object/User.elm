-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.Object.User exposing (..)

import Fractal.InputObject
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


id : SelectionSet Fractal.ScalarCodecs.Id Fractal.Object.User
id =
    Object.selectionForField "ScalarCodecs.Id" "id" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecId |> .decoder)


createdAt : SelectionSet Fractal.ScalarCodecs.DateTime Fractal.Object.User
createdAt =
    Object.selectionForField "ScalarCodecs.DateTime" "createdAt" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


lastAck : SelectionSet Fractal.ScalarCodecs.DateTime Fractal.Object.User
lastAck =
    Object.selectionForField "ScalarCodecs.DateTime" "lastAck" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


username : SelectionSet String Fractal.Object.User
username =
    Object.selectionForField "String" "username" [] Decode.string


name : SelectionSet (Maybe String) Fractal.Object.User
name =
    Object.selectionForField "(Maybe String)" "name" [] (Decode.string |> Decode.nullable)


password : SelectionSet String Fractal.Object.User
password =
    Object.selectionForField "String" "password" [] Decode.string


email : SelectionSet String Fractal.Object.User
email =
    Object.selectionForField "String" "email" [] Decode.string


emailHash : SelectionSet (Maybe String) Fractal.Object.User
emailHash =
    Object.selectionForField "(Maybe String)" "emailHash" [] (Decode.string |> Decode.nullable)


emailValidated : SelectionSet Bool Fractal.Object.User
emailValidated =
    Object.selectionForField "Bool" "emailValidated" [] Decode.bool


bio : SelectionSet (Maybe String) Fractal.Object.User
bio =
    Object.selectionForField "(Maybe String)" "bio" [] (Decode.string |> Decode.nullable)


utc : SelectionSet (Maybe String) Fractal.Object.User
utc =
    Object.selectionForField "(Maybe String)" "utc" [] (Decode.string |> Decode.nullable)


notifyByEmail : SelectionSet (Maybe Bool) Fractal.Object.User
notifyByEmail =
    Object.selectionForField "(Maybe Bool)" "notifyByEmail" [] (Decode.bool |> Decode.nullable)


type alias SubscriptionsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


subscriptions :
    (SubscriptionsOptionalArguments -> SubscriptionsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
subscriptions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "subscriptions" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias RightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter }


rights :
    (RightsOptionalArguments -> RightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRights
    -> SelectionSet decodesTo Fractal.Object.User
rights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rights" optionalArgs____ object____ Basics.identity


type alias RolesOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


roles :
    (RolesOptionalArguments -> RolesOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
roles fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "roles" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias BackedRolesOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


backed_roles :
    (BackedRolesOptionalArguments -> BackedRolesOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
backed_roles fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "backed_roles" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias TensionsCreatedOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


tensions_created :
    (TensionsCreatedOptionalArguments -> TensionsCreatedOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
tensions_created fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_created" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias TensionsAssignedOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


tensions_assigned :
    (TensionsAssignedOptionalArguments -> TensionsAssignedOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
tensions_assigned fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_assigned" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias ContractsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter
    , order : OptionalArgument Fractal.InputObject.ContractOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


contracts :
    (ContractsOptionalArguments -> ContractsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
contracts fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeContractOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contracts" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias EventsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter
    , order : OptionalArgument Fractal.InputObject.UserEventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


events :
    (EventsOptionalArguments -> EventsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEvent
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
events fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "events" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


markAllAsRead : SelectionSet (Maybe String) Fractal.Object.User
markAllAsRead =
    Object.selectionForField "(Maybe String)" "markAllAsRead" [] (Decode.string |> Decode.nullable)


type alias SubscriptionsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


subscriptionsAggregate :
    (SubscriptionsAggregateOptionalArguments -> SubscriptionsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
subscriptionsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "subscriptionsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias RolesAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


rolesAggregate :
    (RolesAggregateOptionalArguments -> RolesAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
rolesAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rolesAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias BackedRolesAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


backed_rolesAggregate :
    (BackedRolesAggregateOptionalArguments -> BackedRolesAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
backed_rolesAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "backed_rolesAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias TensionsCreatedAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


tensions_createdAggregate :
    (TensionsCreatedAggregateOptionalArguments -> TensionsCreatedAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
tensions_createdAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_createdAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias TensionsAssignedAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


tensions_assignedAggregate :
    (TensionsAssignedAggregateOptionalArguments -> TensionsAssignedAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
tensions_assignedAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_assignedAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ContractsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter }


contractsAggregate :
    (ContractsAggregateOptionalArguments -> ContractsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ContractAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
contractsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contractsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias EventsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter }


eventsAggregate :
    (EventsAggregateOptionalArguments -> EventsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEventAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
eventsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "eventsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)
