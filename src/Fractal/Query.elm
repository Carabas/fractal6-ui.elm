-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.Query exposing (..)

import Fractal.InputObject
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias GetNodeOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    }


getNode :
    (GetNodeOptionalArguments -> GetNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
getNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, nameid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "nameid" filledInOptionals____.nameid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryNodeOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryNode :
    (QueryNodeOptionalArguments -> QueryNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateNodeOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


aggregateNode :
    (AggregateNodeOptionalArguments -> AggregateNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetNodeFragmentRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getNodeFragment :
    GetNodeFragmentRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.NodeFragment
    -> SelectionSet (Maybe decodesTo) RootQuery
getNodeFragment requiredArgs____ object____ =
    Object.selectionForCompositeField "getNodeFragment" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryNodeFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFragmentFilter
    , order : OptionalArgument Fractal.InputObject.NodeFragmentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryNodeFragment :
    (QueryNodeFragmentOptionalArguments -> QueryNodeFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeFragment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryNodeFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFragmentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeFragmentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryNodeFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateNodeFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFragmentFilter }


aggregateNodeFragment :
    (AggregateNodeFragmentOptionalArguments -> AggregateNodeFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeFragmentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateNodeFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFragmentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateNodeFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetMandateRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getMandate :
    GetMandateRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Mandate
    -> SelectionSet (Maybe decodesTo) RootQuery
getMandate requiredArgs____ object____ =
    Object.selectionForCompositeField "getMandate" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryMandateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.MandateFilter
    , order : OptionalArgument Fractal.InputObject.MandateOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryMandate :
    (QueryMandateOptionalArguments -> QueryMandateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Mandate
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryMandate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeMandateFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeMandateOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryMandate" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateMandateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.MandateFilter }


aggregateMandate :
    (AggregateMandateOptionalArguments -> AggregateMandateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.MandateAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateMandate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeMandateFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateMandate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetLabelRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getLabel :
    GetLabelRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Label
    -> SelectionSet (Maybe decodesTo) RootQuery
getLabel requiredArgs____ object____ =
    Object.selectionForCompositeField "getLabel" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryLabelOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.LabelFilter
    , order : OptionalArgument Fractal.InputObject.LabelOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryLabel :
    (QueryLabelOptionalArguments -> QueryLabelOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Label
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryLabel fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeLabelFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeLabelOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryLabel" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateLabelOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.LabelFilter }


aggregateLabel :
    (AggregateLabelOptionalArguments -> AggregateLabelOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.LabelAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateLabel fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeLabelFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateLabel" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetRoleExtRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getRoleExt :
    GetRoleExtRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.RoleExt
    -> SelectionSet (Maybe decodesTo) RootQuery
getRoleExt requiredArgs____ object____ =
    Object.selectionForCompositeField "getRoleExt" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryRoleExtOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.RoleExtFilter
    , order : OptionalArgument Fractal.InputObject.RoleExtOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryRoleExt :
    (QueryRoleExtOptionalArguments -> QueryRoleExtOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.RoleExt
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryRoleExt fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeRoleExtFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeRoleExtOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryRoleExt" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateRoleExtOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.RoleExtFilter }


aggregateRoleExt :
    (AggregateRoleExtOptionalArguments -> AggregateRoleExtOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.RoleExtAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateRoleExt fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeRoleExtFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateRoleExt" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryOrgaAggOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.OrgaAggFilter
    , order : OptionalArgument Fractal.InputObject.OrgaAggOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryOrgaAgg :
    (QueryOrgaAggOptionalArguments -> QueryOrgaAggOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.OrgaAgg
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryOrgaAgg fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeOrgaAggFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeOrgaAggOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryOrgaAgg" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateOrgaAggOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.OrgaAggFilter }


aggregateOrgaAgg :
    (AggregateOrgaAggOptionalArguments -> AggregateOrgaAggOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.OrgaAggAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateOrgaAgg fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeOrgaAggFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateOrgaAgg" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetPostRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getPost :
    GetPostRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Post
    -> SelectionSet (Maybe decodesTo) RootQuery
getPost requiredArgs____ object____ =
    Object.selectionForCompositeField "getPost" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryPostOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PostFilter
    , order : OptionalArgument Fractal.InputObject.PostOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryPost :
    (QueryPostOptionalArguments -> QueryPostOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Post
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryPost fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePostFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodePostOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryPost" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregatePostOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PostFilter }


aggregatePost :
    (AggregatePostOptionalArguments -> AggregatePostOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PostAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregatePost fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePostFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregatePost" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetTensionRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getTension :
    GetTensionRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe decodesTo) RootQuery
getTension requiredArgs____ object____ =
    Object.selectionForCompositeField "getTension" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryTensionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryTension :
    (QueryTensionOptionalArguments -> QueryTensionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryTension fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryTension" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateTensionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


aggregateTension :
    (AggregateTensionOptionalArguments -> AggregateTensionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateTension fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateTension" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetCommentRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getComment :
    GetCommentRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Comment
    -> SelectionSet (Maybe decodesTo) RootQuery
getComment requiredArgs____ object____ =
    Object.selectionForCompositeField "getComment" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryCommentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.CommentFilter
    , order : OptionalArgument Fractal.InputObject.CommentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryComment :
    (QueryCommentOptionalArguments -> QueryCommentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Comment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryComment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeCommentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeCommentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryComment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateCommentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.CommentFilter }


aggregateComment :
    (AggregateCommentOptionalArguments -> AggregateCommentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.CommentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateComment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeCommentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateComment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetBlobRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getBlob :
    GetBlobRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Blob
    -> SelectionSet (Maybe decodesTo) RootQuery
getBlob requiredArgs____ object____ =
    Object.selectionForCompositeField "getBlob" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryBlobOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.BlobFilter
    , order : OptionalArgument Fractal.InputObject.BlobOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryBlob :
    (QueryBlobOptionalArguments -> QueryBlobOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Blob
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryBlob fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeBlobFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeBlobOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryBlob" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateBlobOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.BlobFilter }


aggregateBlob :
    (AggregateBlobOptionalArguments -> AggregateBlobOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.BlobAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateBlob fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeBlobFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateBlob" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetEventRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getEvent :
    GetEventRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Event
    -> SelectionSet (Maybe decodesTo) RootQuery
getEvent requiredArgs____ object____ =
    Object.selectionForCompositeField "getEvent" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFilter
    , order : OptionalArgument Fractal.InputObject.EventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryEvent :
    (QueryEventOptionalArguments -> QueryEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Event
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFilter }


aggregateEvent :
    (AggregateEventOptionalArguments -> AggregateEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryEventFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFragmentFilter
    , order : OptionalArgument Fractal.InputObject.EventFragmentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryEventFragment :
    (QueryEventFragmentOptionalArguments -> QueryEventFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventFragment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryEventFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFragmentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeEventFragmentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryEventFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateEventFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFragmentFilter }


aggregateEventFragment :
    (AggregateEventFragmentOptionalArguments -> AggregateEventFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventFragmentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateEventFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFragmentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateEventFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetContractOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , contractid : OptionalArgument String
    }


getContract :
    (GetContractOptionalArguments -> GetContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe decodesTo) RootQuery
getContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, contractid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "contractid" filledInOptionals____.contractid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryContractOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter
    , order : OptionalArgument Fractal.InputObject.ContractOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryContract :
    (QueryContractOptionalArguments -> QueryContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeContractOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateContractOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter }


aggregateContract :
    (AggregateContractOptionalArguments -> AggregateContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ContractAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryPendingUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PendingUserFilter
    , order : OptionalArgument Fractal.InputObject.PendingUserOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryPendingUser :
    (QueryPendingUserOptionalArguments -> QueryPendingUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PendingUser
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryPendingUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePendingUserFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodePendingUserOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryPendingUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregatePendingUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PendingUserFilter }


aggregatePendingUser :
    (AggregatePendingUserOptionalArguments -> AggregatePendingUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PendingUserAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregatePendingUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePendingUserFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregatePendingUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetVoteOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , voteid : OptionalArgument String
    }


getVote :
    (GetVoteOptionalArguments -> GetVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Vote
    -> SelectionSet (Maybe decodesTo) RootQuery
getVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, voteid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "voteid" filledInOptionals____.voteid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryVoteOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.VoteFilter
    , order : OptionalArgument Fractal.InputObject.VoteOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryVote :
    (QueryVoteOptionalArguments -> QueryVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Vote
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeVoteFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeVoteOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateVoteOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.VoteFilter }


aggregateVote :
    (AggregateVoteOptionalArguments -> AggregateVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.VoteAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeVoteFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetUserOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , username : OptionalArgument String
    }


getUser :
    (GetUserOptionalArguments -> GetUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
getUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, username = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "username" filledInOptionals____.username Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserFilter
    , order : OptionalArgument Fractal.InputObject.UserOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUser :
    (QueryUserOptionalArguments -> QueryUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.User
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserFilter }


aggregateUser :
    (AggregateUserOptionalArguments -> AggregateUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryUserEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter
    , order : OptionalArgument Fractal.InputObject.UserEventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUserEvent :
    (QueryUserEventOptionalArguments -> QueryUserEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEvent
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUserEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUserEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter }


aggregateUserEvent :
    (AggregateUserEventOptionalArguments -> AggregateUserEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEventAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUserEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUserEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryUserRightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter
    , order : OptionalArgument Fractal.InputObject.UserRightsOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUserRights :
    (QueryUserRightsOptionalArguments -> QueryUserRightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRights
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUserRights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserRightsOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUserRights" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserRightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter }


aggregateUserRights :
    (AggregateUserRightsOptionalArguments -> AggregateUserRightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRightsAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUserRights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUserRights" optionalArgs____ object____ (Basics.identity >> Decode.nullable)
