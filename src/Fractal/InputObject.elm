-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.BlobOrderable
import Fractal.Enum.BlobType
import Fractal.Enum.CommentOrderable
import Fractal.Enum.EventOrderable
import Fractal.Enum.HTTPMethod
import Fractal.Enum.LabelOrderable
import Fractal.Enum.MandateOrderable
import Fractal.Enum.Mode
import Fractal.Enum.NodeFragmentOrderable
import Fractal.Enum.NodeMode
import Fractal.Enum.NodeOrderable
import Fractal.Enum.NodeStatsOrderable
import Fractal.Enum.NodeType
import Fractal.Enum.PostOrderable
import Fractal.Enum.RoleType
import Fractal.Enum.TensionAction
import Fractal.Enum.TensionEvent
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionStatus
import Fractal.Enum.TensionType
import Fractal.Enum.UserOrderable
import Fractal.Enum.UserRightsOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddBlobInput :
    AddBlobInputRequiredFields
    -> (AddBlobInputOptionalFields -> AddBlobInputOptionalFields)
    -> AddBlobInput
buildAddBlobInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    AddBlobInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = required.tension, blob_type = required.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias AddBlobInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    }


type alias AddBlobInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `AddBlobInput` attributes. Note that this type
needs to use the `AddBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddBlobInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the AddBlobInput input object.
-}
type AddBlobInput
    = AddBlobInput AddBlobInputRaw


{-| Encode a AddBlobInput into a value that can be used as an argument.
-}
encodeAddBlobInput : AddBlobInput -> Value
encodeAddBlobInput (AddBlobInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef input.tension |> Just ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString input.blob_type |> Just ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildAddCommentInput :
    AddCommentInputRequiredFields
    -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields)
    -> AddCommentInput
buildAddCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, void_ = Absent }
    in
    AddCommentInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias AddCommentInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    }


type alias AddCommentInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildAddEventInput :
    AddEventInputRequiredFields
    -> (AddEventInputOptionalFields -> AddEventInputOptionalFields)
    -> AddEventInput
buildAddEventInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, old = Absent, new = Absent }
    in
    AddEventInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, event_type = required.event_type, old = optionals.old, new = optionals.new }


type alias AddEventInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    }


type alias AddEventInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `AddEventInput` attributes. Note that this type
needs to use the `AddEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddEventInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventInput input object.
-}
type AddEventInput
    = AddEventInput AddEventInputRaw


{-| Encode a AddEventInput into a value that can be used as an argument.
-}
encodeAddEventInput : AddEventInput -> Value
encodeAddEventInput (AddEventInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input.event_type |> Just ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildAddLabelInput :
    AddLabelInputRequiredFields
    -> (AddLabelInputOptionalFields -> AddLabelInputOptionalFields)
    -> AddLabelInput
buildAddLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { color = Absent }
    in
    { name = required.name, color = optionals.color }


type alias AddLabelInputRequiredFields =
    { name : String }


type alias AddLabelInputOptionalFields =
    { color : OptionalArgument String }


{-| Type for the AddLabelInput input object.
-}
type alias AddLabelInput =
    { name : String
    , color : OptionalArgument String
    }


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "color", Encode.string |> Encode.optional input.color ) ]


buildAddMandateInput :
    AddMandateInputRequiredFields
    -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields)
    -> AddMandateInput
buildAddMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = required.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias AddMandateInputRequiredFields =
    { purpose : String }


type alias AddMandateInputOptionalFields =
    { responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the AddMandateInput input object.
-}
type alias AddMandateInput =
    { purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput input =
    Encode.maybeObject
        [ ( "purpose", Encode.string input.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildAddNodeCharacInput :
    AddNodeCharacInputRequiredFields
    -> AddNodeCharacInput
buildAddNodeCharacInput required =
    { userCanJoin = required.userCanJoin, mode = required.mode }


type alias AddNodeCharacInputRequiredFields =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the AddNodeCharacInput input object.
-}
type alias AddNodeCharacInput =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a AddNodeCharacInput into a value that can be used as an argument.
-}
encodeAddNodeCharacInput : AddNodeCharacInput -> Value
encodeAddNodeCharacInput input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool input.userCanJoin |> Just ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString input.mode |> Just ) ]


buildAddNodeFragmentInput :
    (AddNodeFragmentInputOptionalFields -> AddNodeFragmentInputOptionalFields)
    -> AddNodeFragmentInput
buildAddNodeFragmentInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    AddNodeFragmentInput { name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias AddNodeFragmentInputOptionalFields =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `AddNodeFragmentInput` attributes. Note that this type
needs to use the `AddNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeFragmentInputRaw =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the AddNodeFragmentInput input object.
-}
type AddNodeFragmentInput
    = AddNodeFragmentInput AddNodeFragmentInputRaw


{-| Encode a AddNodeFragmentInput into a value that can be used as an argument.
-}
encodeAddNodeFragmentInput : AddNodeFragmentInput -> Value
encodeAddNodeFragmentInput (AddNodeFragmentInput input) =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildAddNodeInput :
    AddNodeInputRequiredFields
    -> (AddNodeInputOptionalFields -> AddNodeInputOptionalFields)
    -> AddNodeInput
buildAddNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, parent = Absent, children = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, isPersonal = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    AddNodeInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, name = required.name, nameid = required.nameid, rootnameid = required.rootnameid, parent = optionals.parent, children = optionals.children, type_ = required.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = required.isRoot, isPersonal = optionals.isPersonal, isPrivate = required.isPrivate, isArchived = required.isArchived, charac = required.charac, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias AddNodeInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , type_ : Fractal.Enum.NodeType.NodeType
    , isRoot : Bool
    , isPrivate : Bool
    , isArchived : Bool
    , charac : NodeCharacRef
    }


type alias AddNodeInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isPersonal : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `AddNodeInput` attributes. Note that this type
needs to use the `AddNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : Bool
    , isArchived : Bool
    , charac : NodeCharacRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the AddNodeInput input object.
-}
type AddNodeInput
    = AddNodeInput AddNodeInputRaw


{-| Encode a AddNodeInput into a value that can be used as an argument.
-}
encodeAddNodeInput : AddNodeInput -> Value
encodeAddNodeInput (AddNodeInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string input.name |> Just ), ( "nameid", Encode.string input.nameid |> Just ), ( "rootnameid", Encode.string input.rootnameid |> Just ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString input.type_ |> Just ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool input.isRoot |> Just ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool input.isPrivate |> Just ), ( "isArchived", Encode.bool input.isArchived |> Just ), ( "charac", encodeNodeCharacRef input.charac |> Just ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildAddNodeStatsInput :
    (AddNodeStatsInputOptionalFields -> AddNodeStatsInputOptionalFields)
    -> AddNodeStatsInput
buildAddNodeStatsInput fillOptionals =
    let
        optionals =
            fillOptionals
                { n_member = Absent, n_guest = Absent, n_circle = Absent, n_role = Absent }
    in
    { n_member = optionals.n_member, n_guest = optionals.n_guest, n_circle = optionals.n_circle, n_role = optionals.n_role }


type alias AddNodeStatsInputOptionalFields =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Type for the AddNodeStatsInput input object.
-}
type alias AddNodeStatsInput =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Encode a AddNodeStatsInput into a value that can be used as an argument.
-}
encodeAddNodeStatsInput : AddNodeStatsInput -> Value
encodeAddNodeStatsInput input =
    Encode.maybeObject
        [ ( "n_member", Encode.int |> Encode.optional input.n_member ), ( "n_guest", Encode.int |> Encode.optional input.n_guest ), ( "n_circle", Encode.int |> Encode.optional input.n_circle ), ( "n_role", Encode.int |> Encode.optional input.n_role ) ]


buildAddTensionInput :
    AddTensionInputRequiredFields
    -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields)
    -> AddTensionInput
buildAddTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, nth = Absent, labels = Absent, assignees = Absent, comments = Absent, action = Absent, blobs = Absent, n_comments = Absent, n_blobs = Absent }
    in
    AddTensionInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, nth = optionals.nth, title = required.title, type_ = required.type_, emitterid = required.emitterid, emitter = required.emitter, receiverid = required.receiverid, receiver = required.receiver, status = required.status, labels = optionals.labels, assignees = optionals.assignees, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, history = required.history, n_comments = optionals.n_comments, n_blobs = optionals.n_blobs }


type alias AddTensionInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitterid : String
    , emitter : NodeRef
    , receiverid : String
    , receiver : NodeRef
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , history : List EventRef
    }


type alias AddTensionInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitterid : String
    , emitter : NodeRef
    , receiverid : String
    , receiver : NodeRef
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , history : List EventRef
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string input.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input.type_ |> Just ), ( "emitterid", Encode.string input.emitterid |> Just ), ( "emitter", encodeNodeRef input.emitter |> Just ), ( "receiverid", Encode.string input.receiverid |> Just ), ( "receiver", encodeNodeRef input.receiver |> Just ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString input.status |> Just ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "history", (encodeEventRef |> Encode.list) input.history |> Just ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_blobs", Encode.int |> Encode.optional input.n_blobs ) ]


buildAddUserInput :
    AddUserInputRequiredFields
    -> (AddUserInputOptionalFields -> AddUserInputOptionalFields)
    -> AddUserInput
buildAddUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, emailHash = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, bio = Absent, utc = Absent }
    in
    AddUserInput { createdAt = required.createdAt, lastAck = required.lastAck, username = required.username, name = optionals.name, password = required.password, email = required.email, emailHash = optionals.emailHash, emailValidated = required.emailValidated, rights = required.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, bio = optionals.bio, utc = optionals.utc }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , password : String
    , email : String
    , emailValidated : Bool
    , rights : UserRightsRef
    }


type alias AddUserInputOptionalFields =
    { name : OptionalArgument String
    , emailHash : OptionalArgument String
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , name : OptionalArgument String
    , password : String
    , email : String
    , emailHash : OptionalArgument String
    , emailValidated : Bool
    , rights : UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.lastAck |> Just ), ( "username", Encode.string input.username |> Just ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string input.password |> Just ), ( "email", Encode.string input.email |> Just ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool input.emailValidated |> Just ), ( "rights", encodeUserRightsRef input.rights |> Just ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildAddUserRightsInput :
    AddUserRightsInputRequiredFields
    -> AddUserRightsInput
buildAddUserRightsInput required =
    { canLogin = required.canLogin, canCreateRoot = required.canCreateRoot, maxPublicOrga = required.maxPublicOrga }


type alias AddUserRightsInputRequiredFields =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    }


{-| Type for the AddUserRightsInput input object.
-}
type alias AddUserRightsInput =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    }


{-| Encode a AddUserRightsInput into a value that can be used as an argument.
-}
encodeAddUserRightsInput : AddUserRightsInput -> Value
encodeAddUserRightsInput input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool input.canLogin |> Just ), ( "canCreateRoot", Encode.bool input.canCreateRoot |> Just ), ( "maxPublicOrga", Encode.int input.maxPublicOrga |> Just ) ]


buildAuthRule :
    (AuthRuleOptionalFields -> AuthRuleOptionalFields)
    -> AuthRule
buildAuthRule fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, rule = Absent }
    in
    AuthRule { and = optionals.and, or = optionals.or, not = optionals.not, rule = optionals.rule }


type alias AuthRuleOptionalFields =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type alias for the `AuthRule` attributes. Note that this type
needs to use the `AuthRule` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AuthRuleRaw =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type for the AuthRule input object.
-}
type AuthRule
    = AuthRule AuthRuleRaw


{-| Encode a AuthRule into a value that can be used as an argument.
-}
encodeAuthRule : AuthRule -> Value
encodeAuthRule (AuthRule input) =
    Encode.maybeObject
        [ ( "and", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeAuthRule |> Encode.optional input.not ), ( "rule", Encode.string |> Encode.optional input.rule ) ]


buildBlobFilter :
    (BlobFilterOptionalFields -> BlobFilterOptionalFields)
    -> BlobFilter
buildBlobFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, and = Absent, or = Absent, not = Absent }
    in
    BlobFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, and = optionals.and, or = optionals.or, not = optionals.not }


type alias BlobFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , and : OptionalArgument BlobFilter
    , or : OptionalArgument BlobFilter
    , not : OptionalArgument BlobFilter
    }


{-| Type alias for the `BlobFilter` attributes. Note that this type
needs to use the `BlobFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , and : OptionalArgument BlobFilter
    , or : OptionalArgument BlobFilter
    , not : OptionalArgument BlobFilter
    }


{-| Type for the BlobFilter input object.
-}
type BlobFilter
    = BlobFilter BlobFilterRaw


{-| Encode a BlobFilter into a value that can be used as an argument.
-}
encodeBlobFilter : BlobFilter -> Value
encodeBlobFilter (BlobFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "blob_type", encodeBlobType_hash |> Encode.optional input.blob_type ), ( "pushedFlag", encodeDateTimeFilter |> Encode.optional input.pushedFlag ), ( "archivedFlag", encodeDateTimeFilter |> Encode.optional input.archivedFlag ), ( "and", encodeBlobFilter |> Encode.optional input.and ), ( "or", encodeBlobFilter |> Encode.optional input.or ), ( "not", encodeBlobFilter |> Encode.optional input.not ) ]


buildBlobOrder :
    (BlobOrderOptionalFields -> BlobOrderOptionalFields)
    -> BlobOrder
buildBlobOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    BlobOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias BlobOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type alias for the `BlobOrder` attributes. Note that this type
needs to use the `BlobOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobOrderRaw =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type for the BlobOrder input object.
-}
type BlobOrder
    = BlobOrder BlobOrderRaw


{-| Encode a BlobOrder into a value that can be used as an argument.
-}
encodeBlobOrder : BlobOrder -> Value
encodeBlobOrder (BlobOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input.desc ), ( "then", encodeBlobOrder |> Encode.optional input.then_ ) ]


buildBlobPatch :
    (BlobPatchOptionalFields -> BlobPatchOptionalFields)
    -> BlobPatch
buildBlobPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias BlobPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobPatch` attributes. Note that this type
needs to use the `BlobPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobPatch input object.
-}
type BlobPatch
    = BlobPatch BlobPatchRaw


{-| Encode a BlobPatch into a value that can be used as an argument.
-}
encodeBlobPatch : BlobPatch -> Value
encodeBlobPatch (BlobPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildBlobRef :
    (BlobRefOptionalFields -> BlobRefOptionalFields)
    -> BlobRef
buildBlobRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias BlobRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobRef` attributes. Note that this type
needs to use the `BlobRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobRef input object.
-}
type BlobRef
    = BlobRef BlobRefRaw


{-| Encode a BlobRef into a value that can be used as an argument.
-}
encodeBlobRef : BlobRef -> Value
encodeBlobRef (BlobRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildBlobType_hash :
    BlobType_hashRequiredFields
    -> BlobType_hash
buildBlobType_hash required =
    { eq = required.eq }


type alias BlobType_hashRequiredFields =
    { eq : Fractal.Enum.BlobType.BlobType }


{-| Type for the BlobType\_hash input object.
-}
type alias BlobType_hash =
    { eq : Fractal.Enum.BlobType.BlobType }


{-| Encode a BlobType\_hash into a value that can be used as an argument.
-}
encodeBlobType_hash : BlobType_hash -> Value
encodeBlobType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.BlobType.toString input.eq |> Just ) ]


buildCommentFilter :
    (CommentFilterOptionalFields -> CommentFilterOptionalFields)
    -> CommentFilter
buildCommentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodeCommentFilter |> Encode.optional input.and ), ( "or", encodeCommentFilter |> Encode.optional input.or ), ( "not", encodeCommentFilter |> Encode.optional input.not ) ]


buildCommentOrder :
    (CommentOrderOptionalFields -> CommentOrderOptionalFields)
    -> CommentOrder
buildCommentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeCommentOrder |> Encode.optional input.then_ ) ]


buildCommentPatch :
    (CommentPatchOptionalFields -> CommentPatchOptionalFields)
    -> CommentPatch
buildCommentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias CommentPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCommentRef :
    (CommentRefOptionalFields -> CommentRefOptionalFields)
    -> CommentRef
buildCommentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCustomHTTP :
    CustomHTTPRequiredFields
    -> (CustomHTTPOptionalFields -> CustomHTTPOptionalFields)
    -> CustomHTTP
buildCustomHTTP required fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, graphql = Absent, mode = Absent, forwardHeaders = Absent, secretHeaders = Absent, introspectionHeaders = Absent, skipIntrospection = Absent }
    in
    { url = required.url, method = required.method, body = optionals.body, graphql = optionals.graphql, mode = optionals.mode, forwardHeaders = optionals.forwardHeaders, secretHeaders = optionals.secretHeaders, introspectionHeaders = optionals.introspectionHeaders, skipIntrospection = optionals.skipIntrospection }


type alias CustomHTTPRequiredFields =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    }


type alias CustomHTTPOptionalFields =
    { body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Type for the CustomHTTP input object.
-}
type alias CustomHTTP =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    , body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Encode a CustomHTTP into a value that can be used as an argument.
-}
encodeCustomHTTP : CustomHTTP -> Value
encodeCustomHTTP input =
    Encode.maybeObject
        [ ( "url", Encode.string input.url |> Just ), ( "method", Encode.enum Fractal.Enum.HTTPMethod.toString input.method |> Just ), ( "body", Encode.string |> Encode.optional input.body ), ( "graphql", Encode.string |> Encode.optional input.graphql ), ( "mode", Encode.enum Fractal.Enum.Mode.toString |> Encode.optional input.mode ), ( "forwardHeaders", (Encode.string |> Encode.list) |> Encode.optional input.forwardHeaders ), ( "secretHeaders", (Encode.string |> Encode.list) |> Encode.optional input.secretHeaders ), ( "introspectionHeaders", (Encode.string |> Encode.list) |> Encode.optional input.introspectionHeaders ), ( "skipIntrospection", Encode.bool |> Encode.optional input.skipIntrospection ) ]


buildDateTimeFilter :
    (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields)
    -> DateTimeFilter
buildDateTimeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.eq ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.gt ) ]


buildEventFilter :
    (EventFilterOptionalFields -> EventFilterOptionalFields)
    -> EventFilter
buildEventFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, event_type = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, event_type = optionals.event_type, and = optionals.and, or = optionals.or, not = optionals.not }


type alias EventFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , and : OptionalArgument EventFilter
    , or : OptionalArgument EventFilter
    , not : OptionalArgument EventFilter
    }


{-| Type alias for the `EventFilter` attributes. Note that this type
needs to use the `EventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , and : OptionalArgument EventFilter
    , or : OptionalArgument EventFilter
    , not : OptionalArgument EventFilter
    }


{-| Type for the EventFilter input object.
-}
type EventFilter
    = EventFilter EventFilterRaw


{-| Encode a EventFilter into a value that can be used as an argument.
-}
encodeEventFilter : EventFilter -> Value
encodeEventFilter (EventFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "event_type", encodeTensionEvent_hash |> Encode.optional input.event_type ), ( "and", encodeEventFilter |> Encode.optional input.and ), ( "or", encodeEventFilter |> Encode.optional input.or ), ( "not", encodeEventFilter |> Encode.optional input.not ) ]


buildEventOrder :
    (EventOrderOptionalFields -> EventOrderOptionalFields)
    -> EventOrder
buildEventOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias EventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type alias for the `EventOrder` attributes. Note that this type
needs to use the `EventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type for the EventOrder input object.
-}
type EventOrder
    = EventOrder EventOrderRaw


{-| Encode a EventOrder into a value that can be used as an argument.
-}
encodeEventOrder : EventOrder -> Value
encodeEventOrder (EventOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input.desc ), ( "then", encodeEventOrder |> Encode.optional input.then_ ) ]


buildEventPatch :
    (EventPatchOptionalFields -> EventPatchOptionalFields)
    -> EventPatch
buildEventPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventPatch` attributes. Note that this type
needs to use the `EventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventPatch input object.
-}
type EventPatch
    = EventPatch EventPatchRaw


{-| Encode a EventPatch into a value that can be used as an argument.
-}
encodeEventPatch : EventPatch -> Value
encodeEventPatch (EventPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildEventRef :
    (EventRefOptionalFields -> EventRefOptionalFields)
    -> EventRef
buildEventRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventRef` attributes. Note that this type
needs to use the `EventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventRef input object.
-}
type EventRef
    = EventRef EventRefRaw


{-| Encode a EventRef into a value that can be used as an argument.
-}
encodeEventRef : EventRef -> Value
encodeEventRef (EventRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildFloatFilter :
    (FloatFilterOptionalFields -> FloatFilterOptionalFields)
    -> FloatFilter
buildFloatFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input.eq ), ( "le", Encode.float |> Encode.optional input.le ), ( "lt", Encode.float |> Encode.optional input.lt ), ( "ge", Encode.float |> Encode.optional input.ge ), ( "gt", Encode.float |> Encode.optional input.gt ) ]


buildIntFilter :
    (IntFilterOptionalFields -> IntFilterOptionalFields)
    -> IntFilter
buildIntFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input.eq ), ( "le", Encode.int |> Encode.optional input.le ), ( "lt", Encode.int |> Encode.optional input.lt ), ( "ge", Encode.int |> Encode.optional input.ge ), ( "gt", Encode.int |> Encode.optional input.gt ) ]


buildLabelFilter :
    (LabelFilterOptionalFields -> LabelFilterOptionalFields)
    -> LabelFilter
buildLabelFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals.id, name = optionals.name, and = optionals.and, or = optionals.or, not = optionals.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "name", encodeStringHashFilter |> Encode.optional input.name ), ( "and", encodeLabelFilter |> Encode.optional input.and ), ( "or", encodeLabelFilter |> Encode.optional input.or ), ( "not", encodeLabelFilter |> Encode.optional input.not ) ]


buildLabelOrder :
    (LabelOrderOptionalFields -> LabelOrderOptionalFields)
    -> LabelOrder
buildLabelOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.desc ), ( "then", encodeLabelOrder |> Encode.optional input.then_ ) ]


buildLabelPatch :
    (LabelPatchOptionalFields -> LabelPatchOptionalFields)
    -> LabelPatch
buildLabelPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { color = Absent }
    in
    { color = optionals.color }


type alias LabelPatchOptionalFields =
    { color : OptionalArgument String }


{-| Type for the LabelPatch input object.
-}
type alias LabelPatch =
    { color : OptionalArgument String }


{-| Encode a LabelPatch into a value that can be used as an argument.
-}
encodeLabelPatch : LabelPatch -> Value
encodeLabelPatch input =
    Encode.maybeObject
        [ ( "color", Encode.string |> Encode.optional input.color ) ]


buildLabelRef :
    (LabelRefOptionalFields -> LabelRefOptionalFields)
    -> LabelRef
buildLabelRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, color = Absent }
    in
    { id = optionals.id, name = optionals.name, color = optionals.color }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , color : OptionalArgument String
    }


{-| Type for the LabelRef input object.
-}
type alias LabelRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , color : OptionalArgument String
    }


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "color", Encode.string |> Encode.optional input.color ) ]


buildMandateFilter :
    (MandateFilterOptionalFields -> MandateFilterOptionalFields)
    -> MandateFilter
buildMandateFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, purpose = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals.id, purpose = optionals.purpose, and = optionals.and, or = optionals.or, not = optionals.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input.purpose ), ( "and", encodeMandateFilter |> Encode.optional input.and ), ( "or", encodeMandateFilter |> Encode.optional input.or ), ( "not", encodeMandateFilter |> Encode.optional input.not ) ]


buildMandateOrder :
    (MandateOrderOptionalFields -> MandateOrderOptionalFields)
    -> MandateOrder
buildMandateOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.desc ), ( "then", encodeMandateOrder |> Encode.optional input.then_ ) ]


buildMandatePatch :
    (MandatePatchOptionalFields -> MandatePatchOptionalFields)
    -> MandatePatch
buildMandatePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandatePatchOptionalFields =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandatePatch input object.
-}
type alias MandatePatch =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch input =
    Encode.maybeObject
        [ ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildMandateRef :
    (MandateRefOptionalFields -> MandateRefOptionalFields)
    -> MandateRef
buildMandateRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { id = optionals.id, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandateRef input object.
-}
type alias MandateRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildNodeCharacFilter :
    (NodeCharacFilterOptionalFields -> NodeCharacFilterOptionalFields)
    -> NodeCharacFilter
buildNodeCharacFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeCharacFilter { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeCharacFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , and : OptionalArgument NodeCharacFilter
    , or : OptionalArgument NodeCharacFilter
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type alias for the `NodeCharacFilter` attributes. Note that this type
needs to use the `NodeCharacFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeCharacFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , and : OptionalArgument NodeCharacFilter
    , or : OptionalArgument NodeCharacFilter
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type for the NodeCharacFilter input object.
-}
type NodeCharacFilter
    = NodeCharacFilter NodeCharacFilterRaw


{-| Encode a NodeCharacFilter into a value that can be used as an argument.
-}
encodeNodeCharacFilter : NodeCharacFilter -> Value
encodeNodeCharacFilter (NodeCharacFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", encodeNodeMode_hash |> Encode.optional input.mode ), ( "and", encodeNodeCharacFilter |> Encode.optional input.and ), ( "or", encodeNodeCharacFilter |> Encode.optional input.or ), ( "not", encodeNodeCharacFilter |> Encode.optional input.not ) ]


buildNodeCharacPatch :
    (NodeCharacPatchOptionalFields -> NodeCharacPatchOptionalFields)
    -> NodeCharacPatch
buildNodeCharacPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { userCanJoin = Absent, mode = Absent }
    in
    { userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacPatchOptionalFields =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacPatch input object.
-}
type alias NodeCharacPatch =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacPatch into a value that can be used as an argument.
-}
encodeNodeCharacPatch : NodeCharacPatch -> Value
encodeNodeCharacPatch input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeCharacRef :
    (NodeCharacRefOptionalFields -> NodeCharacRefOptionalFields)
    -> NodeCharacRef
buildNodeCharacRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent }
    in
    { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacRef input object.
-}
type alias NodeCharacRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacRef into a value that can be used as an argument.
-}
encodeNodeCharacRef : NodeCharacRef -> Value
encodeNodeCharacRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeFilter :
    (NodeFilterOptionalFields -> NodeFilterOptionalFields)
    -> NodeFilter
buildNodeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, type_ = Absent, about = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, skills = Absent, role_type = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals.id, createdAt = optionals.createdAt, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, type_ = optionals.type_, about = optionals.about, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, skills = optionals.skills, role_type = optionals.role_type, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.nameid ), ( "rootnameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.rootnameid ), ( "type_", encodeNodeType_hash |> Encode.optional input.type_ ), ( "about", encodeStringFullTextFilter |> Encode.optional input.about ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "skills", encodeStringTermFilter |> Encode.optional input.skills ), ( "role_type", encodeRoleType_hash |> Encode.optional input.role_type ), ( "and", encodeNodeFilter |> Encode.optional input.and ), ( "or", encodeNodeFilter |> Encode.optional input.or ), ( "not", encodeNodeFilter |> Encode.optional input.not ) ]


buildNodeFragmentFilter :
    (NodeFragmentFilterOptionalFields -> NodeFragmentFilterOptionalFields)
    -> NodeFragmentFilter
buildNodeFragmentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, not = Absent }
    in
    NodeFragmentFilter { id = optionals.id, not = optionals.not }


type alias NodeFragmentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type alias for the `NodeFragmentFilter` attributes. Note that this type
needs to use the `NodeFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type for the NodeFragmentFilter input object.
-}
type NodeFragmentFilter
    = NodeFragmentFilter NodeFragmentFilterRaw


{-| Encode a NodeFragmentFilter into a value that can be used as an argument.
-}
encodeNodeFragmentFilter : NodeFragmentFilter -> Value
encodeNodeFragmentFilter (NodeFragmentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "not", encodeNodeFragmentFilter |> Encode.optional input.not ) ]


buildNodeFragmentOrder :
    (NodeFragmentOrderOptionalFields -> NodeFragmentOrderOptionalFields)
    -> NodeFragmentOrder
buildNodeFragmentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeFragmentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type alias for the `NodeFragmentOrder` attributes. Note that this type
needs to use the `NodeFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type for the NodeFragmentOrder input object.
-}
type NodeFragmentOrder
    = NodeFragmentOrder NodeFragmentOrderRaw


{-| Encode a NodeFragmentOrder into a value that can be used as an argument.
-}
encodeNodeFragmentOrder : NodeFragmentOrder -> Value
encodeNodeFragmentOrder (NodeFragmentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeFragmentOrder |> Encode.optional input.then_ ) ]


buildNodeFragmentPatch :
    (NodeFragmentPatchOptionalFields -> NodeFragmentPatchOptionalFields)
    -> NodeFragmentPatch
buildNodeFragmentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodeFragmentPatch { name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodeFragmentPatchOptionalFields =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentPatch` attributes. Note that this type
needs to use the `NodeFragmentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentPatchRaw =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentPatch input object.
-}
type NodeFragmentPatch
    = NodeFragmentPatch NodeFragmentPatchRaw


{-| Encode a NodeFragmentPatch into a value that can be used as an argument.
-}
encodeNodeFragmentPatch : NodeFragmentPatch -> Value
encodeNodeFragmentPatch (NodeFragmentPatch input) =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeFragmentRef :
    (NodeFragmentRefOptionalFields -> NodeFragmentRefOptionalFields)
    -> NodeFragmentRef
buildNodeFragmentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodeFragmentRef { id = optionals.id, name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodeFragmentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentRef` attributes. Note that this type
needs to use the `NodeFragmentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentRef input object.
-}
type NodeFragmentRef
    = NodeFragmentRef NodeFragmentRefRaw


{-| Encode a NodeFragmentRef into a value that can be used as an argument.
-}
encodeNodeFragmentRef : NodeFragmentRef -> Value
encodeNodeFragmentRef (NodeFragmentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeMode_hash :
    NodeMode_hashRequiredFields
    -> NodeMode_hash
buildNodeMode_hash required =
    { eq = required.eq }


type alias NodeMode_hashRequiredFields =
    { eq : Fractal.Enum.NodeMode.NodeMode }


{-| Type for the NodeMode\_hash input object.
-}
type alias NodeMode_hash =
    { eq : Fractal.Enum.NodeMode.NodeMode }


{-| Encode a NodeMode\_hash into a value that can be used as an argument.
-}
encodeNodeMode_hash : NodeMode_hash -> Value
encodeNodeMode_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeMode.toString input.eq |> Just ) ]


buildNodeOrder :
    (NodeOrderOptionalFields -> NodeOrderOptionalFields)
    -> NodeOrder
buildNodeOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeOrder |> Encode.optional input.then_ ) ]


buildNodePatch :
    (NodePatchOptionalFields -> NodePatchOptionalFields)
    -> NodePatch
buildNodePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, charac = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodePatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, name = optionals.name, rootnameid = optionals.rootnameid, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, charac = optionals.charac, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string |> Encode.optional input.name ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeRef :
    (NodeRefOptionalFields -> NodeRefOptionalFields)
    -> NodeRef
buildNodeRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, charac = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodeRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, charac = optionals.charac, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeRef` attributes. Note that this type
needs to use the `NodeRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeRef input object.
-}
type NodeRef
    = NodeRef NodeRefRaw


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef (NodeRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeStatsOrder :
    (NodeStatsOrderOptionalFields -> NodeStatsOrderOptionalFields)
    -> NodeStatsOrder
buildNodeStatsOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeStatsOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeStatsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , desc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , then_ : OptionalArgument NodeStatsOrder
    }


{-| Type alias for the `NodeStatsOrder` attributes. Note that this type
needs to use the `NodeStatsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeStatsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , desc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , then_ : OptionalArgument NodeStatsOrder
    }


{-| Type for the NodeStatsOrder input object.
-}
type NodeStatsOrder
    = NodeStatsOrder NodeStatsOrderRaw


{-| Encode a NodeStatsOrder into a value that can be used as an argument.
-}
encodeNodeStatsOrder : NodeStatsOrder -> Value
encodeNodeStatsOrder (NodeStatsOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeStatsOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeStatsOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeStatsOrder |> Encode.optional input.then_ ) ]


buildNodeStatsRef :
    (NodeStatsRefOptionalFields -> NodeStatsRefOptionalFields)
    -> NodeStatsRef
buildNodeStatsRef fillOptionals =
    let
        optionals =
            fillOptionals
                { n_member = Absent, n_guest = Absent, n_circle = Absent, n_role = Absent }
    in
    { n_member = optionals.n_member, n_guest = optionals.n_guest, n_circle = optionals.n_circle, n_role = optionals.n_role }


type alias NodeStatsRefOptionalFields =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Type for the NodeStatsRef input object.
-}
type alias NodeStatsRef =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Encode a NodeStatsRef into a value that can be used as an argument.
-}
encodeNodeStatsRef : NodeStatsRef -> Value
encodeNodeStatsRef input =
    Encode.maybeObject
        [ ( "n_member", Encode.int |> Encode.optional input.n_member ), ( "n_guest", Encode.int |> Encode.optional input.n_guest ), ( "n_circle", Encode.int |> Encode.optional input.n_circle ), ( "n_role", Encode.int |> Encode.optional input.n_role ) ]


buildNodeType_hash :
    NodeType_hashRequiredFields
    -> NodeType_hash
buildNodeType_hash required =
    { eq = required.eq }


type alias NodeType_hashRequiredFields =
    { eq : Fractal.Enum.NodeType.NodeType }


{-| Type for the NodeType\_hash input object.
-}
type alias NodeType_hash =
    { eq : Fractal.Enum.NodeType.NodeType }


{-| Encode a NodeType\_hash into a value that can be used as an argument.
-}
encodeNodeType_hash : NodeType_hash -> Value
encodeNodeType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeType.toString input.eq |> Just ) ]


buildPostFilter :
    (PostFilterOptionalFields -> PostFilterOptionalFields)
    -> PostFilter
buildPostFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodePostFilter |> Encode.optional input.and ), ( "or", encodePostFilter |> Encode.optional input.or ), ( "not", encodePostFilter |> Encode.optional input.not ) ]


buildPostOrder :
    (PostOrderOptionalFields -> PostOrderOptionalFields)
    -> PostOrder
buildPostOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.desc ), ( "then", encodePostOrder |> Encode.optional input.then_ ) ]


buildPostPatch :
    (PostPatchOptionalFields -> PostPatchOptionalFields)
    -> PostPatch
buildPostPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent }
    in
    PostPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message }


type alias PostPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ) ]


buildPostRef :
    PostRefRequiredFields
    -> PostRef
buildPostRef required =
    { id = required.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input.id |> Just ) ]


buildRoleType_hash :
    (RoleType_hashOptionalFields -> RoleType_hashOptionalFields)
    -> RoleType_hash
buildRoleType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent }
    in
    { eq = optionals.eq }


type alias RoleType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType }


{-| Type for the RoleType\_hash input object.
-}
type alias RoleType_hash =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType }


{-| Encode a RoleType\_hash into a value that can be used as an argument.
-}
encodeRoleType_hash : RoleType_hash -> Value
encodeRoleType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.eq ) ]


buildStringExactFilter :
    (StringExactFilterOptionalFields -> StringExactFilterOptionalFields)
    -> StringExactFilter
buildStringExactFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "le", Encode.string |> Encode.optional input.le ), ( "lt", Encode.string |> Encode.optional input.lt ), ( "ge", Encode.string |> Encode.optional input.ge ), ( "gt", Encode.string |> Encode.optional input.gt ) ]


buildStringFullTextFilter :
    (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields)
    -> StringFullTextFilter
buildStringFullTextFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals.alloftext, anyoftext = optionals.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input.anyoftext ) ]


buildStringHashFilter :
    (StringHashFilterOptionalFields -> StringHashFilterOptionalFields)
    -> StringHashFilter
buildStringHashFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent }
    in
    { eq = optionals.eq }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ) ]


buildStringHashFilter_StringRegExpFilter :
    (StringHashFilter_StringRegExpFilterOptionalFields -> StringHashFilter_StringRegExpFilterOptionalFields)
    -> StringHashFilter_StringRegExpFilter
buildStringHashFilter_StringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, regexp = Absent }
    in
    { eq = optionals.eq, regexp = optionals.regexp }


type alias StringHashFilter_StringRegExpFilterOptionalFields =
    { eq : OptionalArgument String
    , regexp : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringRegExpFilter input object.
-}
type alias StringHashFilter_StringRegExpFilter =
    { eq : OptionalArgument String
    , regexp : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringRegExpFilter : StringHashFilter_StringRegExpFilter -> Value
encodeStringHashFilter_StringRegExpFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringRegExpFilter :
    (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields)
    -> StringRegExpFilter
buildStringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { regexp = Absent }
    in
    { regexp = optionals.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringTermFilter :
    (StringTermFilterOptionalFields -> StringTermFilterOptionalFields)
    -> StringTermFilter
buildStringTermFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals.allofterms, anyofterms = optionals.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input.anyofterms ) ]


buildTensionEvent_hash :
    TensionEvent_hashRequiredFields
    -> TensionEvent_hash
buildTensionEvent_hash required =
    { eq = required.eq }


type alias TensionEvent_hashRequiredFields =
    { eq : Fractal.Enum.TensionEvent.TensionEvent }


{-| Type for the TensionEvent\_hash input object.
-}
type alias TensionEvent_hash =
    { eq : Fractal.Enum.TensionEvent.TensionEvent }


{-| Encode a TensionEvent\_hash into a value that can be used as an argument.
-}
encodeTensionEvent_hash : TensionEvent_hash -> Value
encodeTensionEvent_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionEvent.toString input.eq |> Just ) ]


buildTensionFilter :
    (TensionFilterOptionalFields -> TensionFilterOptionalFields)
    -> TensionFilter
buildTensionFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitterid = Absent, receiverid = Absent, status = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitterid = optionals.emitterid, receiverid = optionals.receiverid, status = optionals.status, and = optionals.and, or = optionals.or, not = optionals.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , status : OptionalArgument TensionStatus_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , status : OptionalArgument TensionStatus_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "nth", encodeStringTermFilter |> Encode.optional input.nth ), ( "title", encodeStringFullTextFilter |> Encode.optional input.title ), ( "type_", encodeTensionType_hash |> Encode.optional input.type_ ), ( "emitterid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.emitterid ), ( "receiverid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.receiverid ), ( "status", encodeTensionStatus_hash |> Encode.optional input.status ), ( "and", encodeTensionFilter |> Encode.optional input.and ), ( "or", encodeTensionFilter |> Encode.optional input.or ), ( "not", encodeTensionFilter |> Encode.optional input.not ) ]


buildTensionOrder :
    (TensionOrderOptionalFields -> TensionOrderOptionalFields)
    -> TensionOrder
buildTensionOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.desc ), ( "then", encodeTensionOrder |> Encode.optional input.then_ ) ]


buildTensionPatch :
    (TensionPatchOptionalFields -> TensionPatchOptionalFields)
    -> TensionPatch
buildTensionPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitterid = Absent, emitter = Absent, receiverid = Absent, receiver = Absent, status = Absent, labels = Absent, assignees = Absent, comments = Absent, action = Absent, blobs = Absent, history = Absent, n_comments = Absent, n_blobs = Absent }
    in
    TensionPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitterid = optionals.emitterid, emitter = optionals.emitter, receiverid = optionals.receiverid, receiver = optionals.receiver, status = optionals.status, labels = optionals.labels, assignees = optionals.assignees, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, history = optionals.history, n_comments = optionals.n_comments, n_blobs = optionals.n_blobs }


type alias TensionPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input.history ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_blobs", Encode.int |> Encode.optional input.n_blobs ) ]


buildTensionRef :
    (TensionRefOptionalFields -> TensionRefOptionalFields)
    -> TensionRef
buildTensionRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitterid = Absent, emitter = Absent, receiverid = Absent, receiver = Absent, status = Absent, labels = Absent, assignees = Absent, comments = Absent, action = Absent, blobs = Absent, history = Absent, n_comments = Absent, n_blobs = Absent }
    in
    TensionRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitterid = optionals.emitterid, emitter = optionals.emitter, receiverid = optionals.receiverid, receiver = optionals.receiver, status = optionals.status, labels = optionals.labels, assignees = optionals.assignees, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, history = optionals.history, n_comments = optionals.n_comments, n_blobs = optionals.n_blobs }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , labels : OptionalArgument (List LabelRef)
    , assignees : OptionalArgument (List UserRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_blobs : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input.history ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_blobs", Encode.int |> Encode.optional input.n_blobs ) ]


buildTensionStatus_hash :
    TensionStatus_hashRequiredFields
    -> TensionStatus_hash
buildTensionStatus_hash required =
    { eq = required.eq }


type alias TensionStatus_hashRequiredFields =
    { eq : Fractal.Enum.TensionStatus.TensionStatus }


{-| Type for the TensionStatus\_hash input object.
-}
type alias TensionStatus_hash =
    { eq : Fractal.Enum.TensionStatus.TensionStatus }


{-| Encode a TensionStatus\_hash into a value that can be used as an argument.
-}
encodeTensionStatus_hash : TensionStatus_hash -> Value
encodeTensionStatus_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionStatus.toString input.eq |> Just ) ]


buildTensionType_hash :
    TensionType_hashRequiredFields
    -> TensionType_hash
buildTensionType_hash required =
    { eq = required.eq }


type alias TensionType_hashRequiredFields =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString input.eq |> Just ) ]


buildUpdateBlobInput :
    UpdateBlobInputRequiredFields
    -> (UpdateBlobInputOptionalFields -> UpdateBlobInputOptionalFields)
    -> UpdateBlobInput
buildUpdateBlobInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateBlobInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateBlobInputRequiredFields =
    { filter : BlobFilter }


type alias UpdateBlobInputOptionalFields =
    { set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type alias for the `UpdateBlobInput` attributes. Note that this type
needs to use the `UpdateBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateBlobInputRaw =
    { filter : BlobFilter
    , set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type for the UpdateBlobInput input object.
-}
type UpdateBlobInput
    = UpdateBlobInput UpdateBlobInputRaw


{-| Encode a UpdateBlobInput into a value that can be used as an argument.
-}
encodeUpdateBlobInput : UpdateBlobInput -> Value
encodeUpdateBlobInput (UpdateBlobInput input) =
    Encode.maybeObject
        [ ( "filter", encodeBlobFilter input.filter |> Just ), ( "set", encodeBlobPatch |> Encode.optional input.set ), ( "remove", encodeBlobPatch |> Encode.optional input.remove ) ]


buildUpdateCommentInput :
    UpdateCommentInputRequiredFields
    -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields)
    -> UpdateCommentInput
buildUpdateCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input.set ), ( "remove", encodeCommentPatch |> Encode.optional input.remove ) ]


buildUpdateEventInput :
    UpdateEventInputRequiredFields
    -> (UpdateEventInputOptionalFields -> UpdateEventInputOptionalFields)
    -> UpdateEventInput
buildUpdateEventInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateEventInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateEventInputRequiredFields =
    { filter : EventFilter }


type alias UpdateEventInputOptionalFields =
    { set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type alias for the `UpdateEventInput` attributes. Note that this type
needs to use the `UpdateEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventInputRaw =
    { filter : EventFilter
    , set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type for the UpdateEventInput input object.
-}
type UpdateEventInput
    = UpdateEventInput UpdateEventInputRaw


{-| Encode a UpdateEventInput into a value that can be used as an argument.
-}
encodeUpdateEventInput : UpdateEventInput -> Value
encodeUpdateEventInput (UpdateEventInput input) =
    Encode.maybeObject
        [ ( "filter", encodeEventFilter input.filter |> Just ), ( "set", encodeEventPatch |> Encode.optional input.set ), ( "remove", encodeEventPatch |> Encode.optional input.remove ) ]


buildUpdateLabelInput :
    UpdateLabelInputRequiredFields
    -> (UpdateLabelInputOptionalFields -> UpdateLabelInputOptionalFields)
    -> UpdateLabelInput
buildUpdateLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateLabelInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateLabelInputRequiredFields =
    { filter : LabelFilter }


type alias UpdateLabelInputOptionalFields =
    { set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type alias for the `UpdateLabelInput` attributes. Note that this type
needs to use the `UpdateLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateLabelInputRaw =
    { filter : LabelFilter
    , set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type for the UpdateLabelInput input object.
-}
type UpdateLabelInput
    = UpdateLabelInput UpdateLabelInputRaw


{-| Encode a UpdateLabelInput into a value that can be used as an argument.
-}
encodeUpdateLabelInput : UpdateLabelInput -> Value
encodeUpdateLabelInput (UpdateLabelInput input) =
    Encode.maybeObject
        [ ( "filter", encodeLabelFilter input.filter |> Just ), ( "set", encodeLabelPatch |> Encode.optional input.set ), ( "remove", encodeLabelPatch |> Encode.optional input.remove ) ]


buildUpdateMandateInput :
    UpdateMandateInputRequiredFields
    -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields)
    -> UpdateMandateInput
buildUpdateMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input.set ), ( "remove", encodeMandatePatch |> Encode.optional input.remove ) ]


buildUpdateNodeCharacInput :
    UpdateNodeCharacInputRequiredFields
    -> (UpdateNodeCharacInputOptionalFields -> UpdateNodeCharacInputOptionalFields)
    -> UpdateNodeCharacInput
buildUpdateNodeCharacInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeCharacInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeCharacInputRequiredFields =
    { filter : NodeCharacFilter }


type alias UpdateNodeCharacInputOptionalFields =
    { set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type alias for the `UpdateNodeCharacInput` attributes. Note that this type
needs to use the `UpdateNodeCharacInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeCharacInputRaw =
    { filter : NodeCharacFilter
    , set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type for the UpdateNodeCharacInput input object.
-}
type UpdateNodeCharacInput
    = UpdateNodeCharacInput UpdateNodeCharacInputRaw


{-| Encode a UpdateNodeCharacInput into a value that can be used as an argument.
-}
encodeUpdateNodeCharacInput : UpdateNodeCharacInput -> Value
encodeUpdateNodeCharacInput (UpdateNodeCharacInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeCharacFilter input.filter |> Just ), ( "set", encodeNodeCharacPatch |> Encode.optional input.set ), ( "remove", encodeNodeCharacPatch |> Encode.optional input.remove ) ]


buildUpdateNodeFragmentInput :
    UpdateNodeFragmentInputRequiredFields
    -> (UpdateNodeFragmentInputOptionalFields -> UpdateNodeFragmentInputOptionalFields)
    -> UpdateNodeFragmentInput
buildUpdateNodeFragmentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeFragmentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeFragmentInputRequiredFields =
    { filter : NodeFragmentFilter }


type alias UpdateNodeFragmentInputOptionalFields =
    { set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type alias for the `UpdateNodeFragmentInput` attributes. Note that this type
needs to use the `UpdateNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeFragmentInputRaw =
    { filter : NodeFragmentFilter
    , set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type for the UpdateNodeFragmentInput input object.
-}
type UpdateNodeFragmentInput
    = UpdateNodeFragmentInput UpdateNodeFragmentInputRaw


{-| Encode a UpdateNodeFragmentInput into a value that can be used as an argument.
-}
encodeUpdateNodeFragmentInput : UpdateNodeFragmentInput -> Value
encodeUpdateNodeFragmentInput (UpdateNodeFragmentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFragmentFilter input.filter |> Just ), ( "set", encodeNodeFragmentPatch |> Encode.optional input.set ), ( "remove", encodeNodeFragmentPatch |> Encode.optional input.remove ) ]


buildUpdateNodeInput :
    UpdateNodeInputRequiredFields
    -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields)
    -> UpdateNodeInput
buildUpdateNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input.set ), ( "remove", encodeNodePatch |> Encode.optional input.remove ) ]


buildUpdatePostInput :
    UpdatePostInputRequiredFields
    -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields)
    -> UpdatePostInput
buildUpdatePostInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input.set ), ( "remove", encodePostPatch |> Encode.optional input.remove ) ]


buildUpdateTensionInput :
    UpdateTensionInputRequiredFields
    -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields)
    -> UpdateTensionInput
buildUpdateTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input.set ), ( "remove", encodeTensionPatch |> Encode.optional input.remove ) ]


buildUpdateUserInput :
    UpdateUserInputRequiredFields
    -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields)
    -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input.set ), ( "remove", encodeUserPatch |> Encode.optional input.remove ) ]


buildUserFilter :
    (UserFilterOptionalFields -> UserFilterOptionalFields)
    -> UserFilter
buildUserFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, username = Absent, email = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals.id, username = optionals.username, email = optionals.email, and = optionals.and, or = optionals.or, not = optionals.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "username", encodeStringHashFilter |> Encode.optional input.username ), ( "email", encodeStringHashFilter |> Encode.optional input.email ), ( "and", encodeUserFilter |> Encode.optional input.and ), ( "or", encodeUserFilter |> Encode.optional input.or ), ( "not", encodeUserFilter |> Encode.optional input.not ) ]


buildUserOrder :
    (UserOrderOptionalFields -> UserOrderOptionalFields)
    -> UserOrder
buildUserOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserOrder |> Encode.optional input.then_ ) ]


buildUserPatch :
    (UserPatchOptionalFields -> UserPatchOptionalFields)
    -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, lastAck = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, bio = Absent, utc = Absent }
    in
    UserPatch { createdAt = optionals.createdAt, lastAck = optionals.lastAck, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, bio = optionals.bio, utc = optionals.utc }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lastAck ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRef :
    (UserRefOptionalFields -> UserRefOptionalFields)
    -> UserRef
buildUserRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, lastAck = Absent, username = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, bio = Absent, utc = Absent }
    in
    UserRef { id = optionals.id, createdAt = optionals.createdAt, lastAck = optionals.lastAck, username = optionals.username, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, bio = optionals.bio, utc = optionals.utc }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lastAck ), ( "username", Encode.string |> Encode.optional input.username ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRightsOrder :
    (UserRightsOrderOptionalFields -> UserRightsOrderOptionalFields)
    -> UserRightsOrder
buildUserRightsOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserRightsOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserRightsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type alias for the `UserRightsOrder` attributes. Note that this type
needs to use the `UserRightsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type for the UserRightsOrder input object.
-}
type UserRightsOrder
    = UserRightsOrder UserRightsOrderRaw


{-| Encode a UserRightsOrder into a value that can be used as an argument.
-}
encodeUserRightsOrder : UserRightsOrder -> Value
encodeUserRightsOrder (UserRightsOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserRightsOrder |> Encode.optional input.then_ ) ]


buildUserRightsRef :
    (UserRightsRefOptionalFields -> UserRightsRefOptionalFields)
    -> UserRightsRef
buildUserRightsRef fillOptionals =
    let
        optionals =
            fillOptionals
                { canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent }
    in
    { canLogin = optionals.canLogin, canCreateRoot = optionals.canCreateRoot, maxPublicOrga = optionals.maxPublicOrga }


type alias UserRightsRefOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    }


{-| Type for the UserRightsRef input object.
-}
type alias UserRightsRef =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    }


{-| Encode a UserRightsRef into a value that can be used as an argument.
-}
encodeUserRightsRef : UserRightsRef -> Value
encodeUserRightsRef input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input.maxPublicOrga ) ]
