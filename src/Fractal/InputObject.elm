-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.CommentOrderable
import Fractal.Enum.HTTPMethod
import Fractal.Enum.LabelOrderable
import Fractal.Enum.MandateOrderable
import Fractal.Enum.Mode
import Fractal.Enum.NodeMode
import Fractal.Enum.NodeOrderable
import Fractal.Enum.NodeStatsOrderable
import Fractal.Enum.NodeType
import Fractal.Enum.PostOrderable
import Fractal.Enum.RoleType
import Fractal.Enum.TensionAction
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionStatus
import Fractal.Enum.TensionType
import Fractal.Enum.UserOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddCommentInput : AddCommentInputRequiredFields -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields) -> AddCommentInput
buildAddCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { message = Absent, void_ = Absent }
    in
    AddCommentInput { createdAt = required.createdAt, createdBy = required.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias AddCommentInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    }


type alias AddCommentInputOptionalFields =
    { message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildAddLabelInput : AddLabelInputRequiredFields -> (AddLabelInputOptionalFields -> AddLabelInputOptionalFields) -> AddLabelInput
buildAddLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { color = Absent }
    in
    { name = required.name, color = optionals.color }


type alias AddLabelInputRequiredFields =
    { name : String }


type alias AddLabelInputOptionalFields =
    { color : OptionalArgument String }


{-| Type for the AddLabelInput input object.
-}
type alias AddLabelInput =
    { name : String
    , color : OptionalArgument String
    }


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "color", Encode.string |> Encode.optional input.color ) ]


buildAddMandateInput : AddMandateInputRequiredFields -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields) -> AddMandateInput
buildAddMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { responsabilities = Absent, domains = Absent, policies = Absent }
    in
    AddMandateInput { tensions = required.tensions, purpose = required.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias AddMandateInputRequiredFields =
    { tensions : List TensionRef
    , purpose : String
    }


type alias AddMandateInputOptionalFields =
    { responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type alias for the `AddMandateInput` attributes. Note that this type
needs to use the `AddMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddMandateInputRaw =
    { tensions : List TensionRef
    , purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the AddMandateInput input object.
-}
type AddMandateInput
    = AddMandateInput AddMandateInputRaw


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput (AddMandateInput input) =
    Encode.maybeObject
        [ ( "tensions", (encodeTensionRef |> Encode.list) input.tensions |> Just ), ( "purpose", Encode.string input.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildAddNodeCharacInput : AddNodeCharacInputRequiredFields -> AddNodeCharacInput
buildAddNodeCharacInput required =
    { userCanJoin = required.userCanJoin, mode = required.mode }


type alias AddNodeCharacInputRequiredFields =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the AddNodeCharacInput input object.
-}
type alias AddNodeCharacInput =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a AddNodeCharacInput into a value that can be used as an argument.
-}
encodeAddNodeCharacInput : AddNodeCharacInput -> Value
encodeAddNodeCharacInput input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool input.userCanJoin |> Just ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString input.mode |> Just ) ]


buildAddNodeInput : AddNodeInputRequiredFields -> (AddNodeInputOptionalFields -> AddNodeInputOptionalFields) -> AddNodeInput
buildAddNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { parent = Absent, children = Absent, tensions_out = Absent, tensions_in = Absent, mandate = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    AddNodeInput { createdAt = required.createdAt, createdBy = required.createdBy, parent = optionals.parent, children = optionals.children, type_ = required.type_, name = required.name, nameid = required.nameid, rootnameid = required.rootnameid, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, mandate = optionals.mandate, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = required.isRoot, isPrivate = required.isPrivate, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, charac = required.charac }


type alias AddNodeInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , type_ : Fractal.Enum.NodeType.NodeType
    , name : String
    , nameid : String
    , rootnameid : String
    , isRoot : Bool
    , isPrivate : Bool
    , charac : NodeCharacRef
    }


type alias AddNodeInputOptionalFields =
    { parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `AddNodeInput` attributes. Note that this type
needs to use the `AddNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : Fractal.Enum.NodeType.NodeType
    , name : String
    , nameid : String
    , rootnameid : String
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : Bool
    , isPrivate : Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , charac : NodeCharacRef
    }


{-| Type for the AddNodeInput input object.
-}
type AddNodeInput
    = AddNodeInput AddNodeInputRaw


{-| Encode a AddNodeInput into a value that can be used as an argument.
-}
encodeAddNodeInput : AddNodeInput -> Value
encodeAddNodeInput (AddNodeInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString input.type_ |> Just ), ( "name", Encode.string input.name |> Just ), ( "nameid", Encode.string input.nameid |> Just ), ( "rootnameid", Encode.string input.rootnameid |> Just ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool input.isRoot |> Just ), ( "isPrivate", Encode.bool input.isPrivate |> Just ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "charac", encodeNodeCharacRef input.charac |> Just ) ]


buildAddNodeStatsInput : (AddNodeStatsInputOptionalFields -> AddNodeStatsInputOptionalFields) -> AddNodeStatsInput
buildAddNodeStatsInput fillOptionals =
    let
        optionals =
            fillOptionals
                { n_member = Absent, n_guest = Absent, n_circle = Absent, n_role = Absent }
    in
    { n_member = optionals.n_member, n_guest = optionals.n_guest, n_circle = optionals.n_circle, n_role = optionals.n_role }


type alias AddNodeStatsInputOptionalFields =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Type for the AddNodeStatsInput input object.
-}
type alias AddNodeStatsInput =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Encode a AddNodeStatsInput into a value that can be used as an argument.
-}
encodeAddNodeStatsInput : AddNodeStatsInput -> Value
encodeAddNodeStatsInput input =
    Encode.maybeObject
        [ ( "n_member", Encode.int |> Encode.optional input.n_member ), ( "n_guest", Encode.int |> Encode.optional input.n_guest ), ( "n_circle", Encode.int |> Encode.optional input.n_circle ), ( "n_role", Encode.int |> Encode.optional input.n_role ) ]


buildAddTensionInput : AddTensionInputRequiredFields -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields) -> AddTensionInput
buildAddTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { message = Absent, nth = Absent, comments = Absent, labels = Absent, action = Absent, mandate = Absent, n_comments = Absent }
    in
    AddTensionInput { createdAt = required.createdAt, createdBy = required.createdBy, message = optionals.message, nth = optionals.nth, title = required.title, type_ = required.type_, emitter = required.emitter, emitterid = required.emitterid, receiver = required.receiver, receiverid = required.receiverid, comments = optionals.comments, labels = optionals.labels, status = required.status, action = optionals.action, mandate = optionals.mandate, n_comments = optionals.n_comments }


type alias AddTensionInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , status : Fractal.Enum.TensionStatus.TensionStatus
    }


type alias AddTensionInputOptionalFields =
    { message : OptionalArgument String
    , nth : OptionalArgument String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string input.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input.type_ |> Just ), ( "emitter", encodeNodeRef input.emitter |> Just ), ( "emitterid", Encode.string input.emitterid |> Just ), ( "receiver", encodeNodeRef input.receiver |> Just ), ( "receiverid", Encode.string input.receiverid |> Just ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString input.status |> Just ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildAddUserInput : AddUserInputRequiredFields -> (AddUserInputOptionalFields -> AddUserInputOptionalFields) -> AddUserInput
buildAddUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, emailHash = Absent, roles = Absent, backed_roles = Absent, bio = Absent, utc = Absent }
    in
    AddUserInput { createdAt = required.createdAt, username = required.username, name = optionals.name, password = required.password, email = required.email, emailHash = optionals.emailHash, emailValidated = required.emailValidated, rights = required.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio, utc = optionals.utc }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , username : String
    , password : String
    , email : String
    , emailValidated : Bool
    , rights : UserRightsRef
    }


type alias AddUserInputOptionalFields =
    { name : OptionalArgument String
    , emailHash : OptionalArgument String
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , username : String
    , name : OptionalArgument String
    , password : String
    , email : String
    , emailHash : OptionalArgument String
    , emailValidated : Bool
    , rights : UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "username", Encode.string input.username |> Just ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string input.password |> Just ), ( "email", Encode.string input.email |> Just ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool input.emailValidated |> Just ), ( "rights", encodeUserRightsRef input.rights |> Just ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildAddUserRightsInput : AddUserRightsInputRequiredFields -> AddUserRightsInput
buildAddUserRightsInput required =
    { canLogin = required.canLogin, canCreateRoot = required.canCreateRoot }


type alias AddUserRightsInputRequiredFields =
    { canLogin : Bool
    , canCreateRoot : Bool
    }


{-| Type for the AddUserRightsInput input object.
-}
type alias AddUserRightsInput =
    { canLogin : Bool
    , canCreateRoot : Bool
    }


{-| Encode a AddUserRightsInput into a value that can be used as an argument.
-}
encodeAddUserRightsInput : AddUserRightsInput -> Value
encodeAddUserRightsInput input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool input.canLogin |> Just ), ( "canCreateRoot", Encode.bool input.canCreateRoot |> Just ) ]


buildAuthRule : (AuthRuleOptionalFields -> AuthRuleOptionalFields) -> AuthRule
buildAuthRule fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, rule = Absent }
    in
    AuthRule { and = optionals.and, or = optionals.or, not = optionals.not, rule = optionals.rule }


type alias AuthRuleOptionalFields =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type alias for the `AuthRule` attributes. Note that this type
needs to use the `AuthRule` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AuthRuleRaw =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type for the AuthRule input object.
-}
type AuthRule
    = AuthRule AuthRuleRaw


{-| Encode a AuthRule into a value that can be used as an argument.
-}
encodeAuthRule : AuthRule -> Value
encodeAuthRule (AuthRule input) =
    Encode.maybeObject
        [ ( "and", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeAuthRule |> Encode.optional input.not ), ( "rule", Encode.string |> Encode.optional input.rule ) ]


buildCommentFilter : (CommentFilterOptionalFields -> CommentFilterOptionalFields) -> CommentFilter
buildCommentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodeCommentFilter |> Encode.optional input.and ), ( "or", encodeCommentFilter |> Encode.optional input.or ), ( "not", encodeCommentFilter |> Encode.optional input.not ) ]


buildCommentOrder : (CommentOrderOptionalFields -> CommentOrderOptionalFields) -> CommentOrder
buildCommentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeCommentOrder |> Encode.optional input.then_ ) ]


buildCommentPatch : (CommentPatchOptionalFields -> CommentPatchOptionalFields) -> CommentPatch
buildCommentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent, void_ = Absent }
    in
    CommentPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias CommentPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCommentRef : (CommentRefOptionalFields -> CommentRefOptionalFields) -> CommentRef
buildCommentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, message = Absent, void_ = Absent }
    in
    CommentRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCustomHTTP : CustomHTTPRequiredFields -> (CustomHTTPOptionalFields -> CustomHTTPOptionalFields) -> CustomHTTP
buildCustomHTTP required fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, graphql = Absent, mode = Absent, forwardHeaders = Absent, secretHeaders = Absent, skipIntrospection = Absent }
    in
    { url = required.url, method = required.method, body = optionals.body, graphql = optionals.graphql, mode = optionals.mode, forwardHeaders = optionals.forwardHeaders, secretHeaders = optionals.secretHeaders, skipIntrospection = optionals.skipIntrospection }


type alias CustomHTTPRequiredFields =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    }


type alias CustomHTTPOptionalFields =
    { body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Type for the CustomHTTP input object.
-}
type alias CustomHTTP =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    , body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Encode a CustomHTTP into a value that can be used as an argument.
-}
encodeCustomHTTP : CustomHTTP -> Value
encodeCustomHTTP input =
    Encode.maybeObject
        [ ( "url", Encode.string input.url |> Just ), ( "method", Encode.enum Fractal.Enum.HTTPMethod.toString input.method |> Just ), ( "body", Encode.string |> Encode.optional input.body ), ( "graphql", Encode.string |> Encode.optional input.graphql ), ( "mode", Encode.enum Fractal.Enum.Mode.toString |> Encode.optional input.mode ), ( "forwardHeaders", (Encode.string |> Encode.list) |> Encode.optional input.forwardHeaders ), ( "secretHeaders", (Encode.string |> Encode.list) |> Encode.optional input.secretHeaders ), ( "skipIntrospection", Encode.bool |> Encode.optional input.skipIntrospection ) ]


buildDateTimeFilter : (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields) -> DateTimeFilter
buildDateTimeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.eq ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.gt ) ]


buildFloatFilter : (FloatFilterOptionalFields -> FloatFilterOptionalFields) -> FloatFilter
buildFloatFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input.eq ), ( "le", Encode.float |> Encode.optional input.le ), ( "lt", Encode.float |> Encode.optional input.lt ), ( "ge", Encode.float |> Encode.optional input.ge ), ( "gt", Encode.float |> Encode.optional input.gt ) ]


buildIntFilter : (IntFilterOptionalFields -> IntFilterOptionalFields) -> IntFilter
buildIntFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input.eq ), ( "le", Encode.int |> Encode.optional input.le ), ( "lt", Encode.int |> Encode.optional input.lt ), ( "ge", Encode.int |> Encode.optional input.ge ), ( "gt", Encode.int |> Encode.optional input.gt ) ]


buildLabelFilter : (LabelFilterOptionalFields -> LabelFilterOptionalFields) -> LabelFilter
buildLabelFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals.id, name = optionals.name, and = optionals.and, or = optionals.or, not = optionals.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "name", encodeStringHashFilter |> Encode.optional input.name ), ( "and", encodeLabelFilter |> Encode.optional input.and ), ( "or", encodeLabelFilter |> Encode.optional input.or ), ( "not", encodeLabelFilter |> Encode.optional input.not ) ]


buildLabelOrder : (LabelOrderOptionalFields -> LabelOrderOptionalFields) -> LabelOrder
buildLabelOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.desc ), ( "then", encodeLabelOrder |> Encode.optional input.then_ ) ]


buildLabelPatch : (LabelPatchOptionalFields -> LabelPatchOptionalFields) -> LabelPatch
buildLabelPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { color = Absent }
    in
    { color = optionals.color }


type alias LabelPatchOptionalFields =
    { color : OptionalArgument String }


{-| Type for the LabelPatch input object.
-}
type alias LabelPatch =
    { color : OptionalArgument String }


{-| Encode a LabelPatch into a value that can be used as an argument.
-}
encodeLabelPatch : LabelPatch -> Value
encodeLabelPatch input =
    Encode.maybeObject
        [ ( "color", Encode.string |> Encode.optional input.color ) ]


buildLabelRef : (LabelRefOptionalFields -> LabelRefOptionalFields) -> LabelRef
buildLabelRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, color = Absent }
    in
    { id = optionals.id, name = optionals.name, color = optionals.color }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , color : OptionalArgument String
    }


{-| Type for the LabelRef input object.
-}
type alias LabelRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , color : OptionalArgument String
    }


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "color", Encode.string |> Encode.optional input.color ) ]


buildMandateFilter : (MandateFilterOptionalFields -> MandateFilterOptionalFields) -> MandateFilter
buildMandateFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, purpose = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals.id, purpose = optionals.purpose, and = optionals.and, or = optionals.or, not = optionals.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input.purpose ), ( "and", encodeMandateFilter |> Encode.optional input.and ), ( "or", encodeMandateFilter |> Encode.optional input.or ), ( "not", encodeMandateFilter |> Encode.optional input.not ) ]


buildMandateOrder : (MandateOrderOptionalFields -> MandateOrderOptionalFields) -> MandateOrder
buildMandateOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.desc ), ( "then", encodeMandateOrder |> Encode.optional input.then_ ) ]


buildMandatePatch : (MandatePatchOptionalFields -> MandatePatchOptionalFields) -> MandatePatch
buildMandatePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { tensions = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    MandatePatch { tensions = optionals.tensions, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandatePatchOptionalFields =
    { tensions : OptionalArgument (List TensionRef)
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type alias for the `MandatePatch` attributes. Note that this type
needs to use the `MandatePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandatePatchRaw =
    { tensions : OptionalArgument (List TensionRef)
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandatePatch input object.
-}
type MandatePatch
    = MandatePatch MandatePatchRaw


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch (MandatePatch input) =
    Encode.maybeObject
        [ ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildMandateRef : (MandateRefOptionalFields -> MandateRefOptionalFields) -> MandateRef
buildMandateRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, tensions = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    MandateRef { id = optionals.id, tensions = optionals.tensions, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , tensions : OptionalArgument (List TensionRef)
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type alias for the `MandateRef` attributes. Note that this type
needs to use the `MandateRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , tensions : OptionalArgument (List TensionRef)
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandateRef input object.
-}
type MandateRef
    = MandateRef MandateRefRaw


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef (MandateRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildNodeCharacFilter : (NodeCharacFilterOptionalFields -> NodeCharacFilterOptionalFields) -> NodeCharacFilter
buildNodeCharacFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeCharacFilter { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeCharacFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , and : OptionalArgument NodeCharacFilter
    , or : OptionalArgument NodeCharacFilter
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type alias for the `NodeCharacFilter` attributes. Note that this type
needs to use the `NodeCharacFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeCharacFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , and : OptionalArgument NodeCharacFilter
    , or : OptionalArgument NodeCharacFilter
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type for the NodeCharacFilter input object.
-}
type NodeCharacFilter
    = NodeCharacFilter NodeCharacFilterRaw


{-| Encode a NodeCharacFilter into a value that can be used as an argument.
-}
encodeNodeCharacFilter : NodeCharacFilter -> Value
encodeNodeCharacFilter (NodeCharacFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", encodeNodeMode_hash |> Encode.optional input.mode ), ( "and", encodeNodeCharacFilter |> Encode.optional input.and ), ( "or", encodeNodeCharacFilter |> Encode.optional input.or ), ( "not", encodeNodeCharacFilter |> Encode.optional input.not ) ]


buildNodeCharacPatch : (NodeCharacPatchOptionalFields -> NodeCharacPatchOptionalFields) -> NodeCharacPatch
buildNodeCharacPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { userCanJoin = Absent, mode = Absent }
    in
    { userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacPatchOptionalFields =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacPatch input object.
-}
type alias NodeCharacPatch =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacPatch into a value that can be used as an argument.
-}
encodeNodeCharacPatch : NodeCharacPatch -> Value
encodeNodeCharacPatch input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeCharacRef : (NodeCharacRefOptionalFields -> NodeCharacRefOptionalFields) -> NodeCharacRef
buildNodeCharacRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent }
    in
    { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacRef input object.
-}
type alias NodeCharacRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacRef into a value that can be used as an argument.
-}
encodeNodeCharacRef : NodeCharacRef -> Value
encodeNodeCharacRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeFilter : (NodeFilterOptionalFields -> NodeFilterOptionalFields) -> NodeFilter
buildNodeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, type_ = Absent, name = Absent, nameid = Absent, rootnameid = Absent, isRoot = Absent, isPrivate = Absent, skills = Absent, role_type = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals.id, createdAt = optionals.createdAt, type_ = optionals.type_, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, isRoot = optionals.isRoot, isPrivate = optionals.isPrivate, skills = optionals.skills, role_type = optionals.role_type, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , type_ : OptionalArgument NodeType_hash
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , rootnameid : OptionalArgument StringHashFilter
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , type_ : OptionalArgument NodeType_hash
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , rootnameid : OptionalArgument StringHashFilter
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "type_", encodeNodeType_hash |> Encode.optional input.type_ ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter |> Encode.optional input.nameid ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input.rootnameid ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "skills", encodeStringTermFilter |> Encode.optional input.skills ), ( "role_type", encodeRoleType_hash |> Encode.optional input.role_type ), ( "and", encodeNodeFilter |> Encode.optional input.and ), ( "or", encodeNodeFilter |> Encode.optional input.or ), ( "not", encodeNodeFilter |> Encode.optional input.not ) ]


buildNodeMode_hash : NodeMode_hashRequiredFields -> NodeMode_hash
buildNodeMode_hash required =
    { eq = required.eq }


type alias NodeMode_hashRequiredFields =
    { eq : Fractal.Enum.NodeMode.NodeMode }


{-| Type for the NodeMode\_hash input object.
-}
type alias NodeMode_hash =
    { eq : Fractal.Enum.NodeMode.NodeMode }


{-| Encode a NodeMode\_hash into a value that can be used as an argument.
-}
encodeNodeMode_hash : NodeMode_hash -> Value
encodeNodeMode_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeMode.toString input.eq |> Just ) ]


buildNodeOrder : (NodeOrderOptionalFields -> NodeOrderOptionalFields) -> NodeOrder
buildNodeOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeOrder |> Encode.optional input.then_ ) ]


buildNodePatch : (NodePatchOptionalFields -> NodePatchOptionalFields) -> NodePatch
buildNodePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, type_ = Absent, name = Absent, rootnameid = Absent, tensions_out = Absent, tensions_in = Absent, mandate = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, isRoot = Absent, isPrivate = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, charac = Absent }
    in
    NodePatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, name = optionals.name, rootnameid = optionals.rootnameid, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, mandate = optionals.mandate, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = optionals.isRoot, isPrivate = optionals.isPrivate, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, charac = optionals.charac }


type alias NodePatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , charac : OptionalArgument NodeCharacRef
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , charac : OptionalArgument NodeCharacRef
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "name", Encode.string |> Encode.optional input.name ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ) ]


buildNodeRef : (NodeRefOptionalFields -> NodeRefOptionalFields) -> NodeRef
buildNodeRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, type_ = Absent, name = Absent, nameid = Absent, rootnameid = Absent, tensions_out = Absent, tensions_in = Absent, mandate = Absent, n_tensions_out = Absent, n_tensions_in = Absent, n_children = Absent, stats = Absent, isRoot = Absent, isPrivate = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, charac = Absent }
    in
    NodeRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, mandate = optionals.mandate, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, n_children = optionals.n_children, stats = optionals.stats, isRoot = optionals.isRoot, isPrivate = optionals.isPrivate, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, charac = optionals.charac }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , charac : OptionalArgument NodeCharacRef
    }


{-| Type alias for the `NodeRef` attributes. Note that this type
needs to use the `NodeRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , mandate : OptionalArgument MandateRef
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , n_children : OptionalArgument Int
    , stats : OptionalArgument NodeStatsRef
    , isRoot : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , charac : OptionalArgument NodeCharacRef
    }


{-| Type for the NodeRef input object.
-}
type NodeRef
    = NodeRef NodeRefRaw


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef (NodeRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "n_children", Encode.int |> Encode.optional input.n_children ), ( "stats", encodeNodeStatsRef |> Encode.optional input.stats ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ) ]


buildNodeStatsOrder : (NodeStatsOrderOptionalFields -> NodeStatsOrderOptionalFields) -> NodeStatsOrder
buildNodeStatsOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeStatsOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeStatsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , desc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , then_ : OptionalArgument NodeStatsOrder
    }


{-| Type alias for the `NodeStatsOrder` attributes. Note that this type
needs to use the `NodeStatsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeStatsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , desc : OptionalArgument Fractal.Enum.NodeStatsOrderable.NodeStatsOrderable
    , then_ : OptionalArgument NodeStatsOrder
    }


{-| Type for the NodeStatsOrder input object.
-}
type NodeStatsOrder
    = NodeStatsOrder NodeStatsOrderRaw


{-| Encode a NodeStatsOrder into a value that can be used as an argument.
-}
encodeNodeStatsOrder : NodeStatsOrder -> Value
encodeNodeStatsOrder (NodeStatsOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeStatsOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeStatsOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeStatsOrder |> Encode.optional input.then_ ) ]


buildNodeStatsRef : (NodeStatsRefOptionalFields -> NodeStatsRefOptionalFields) -> NodeStatsRef
buildNodeStatsRef fillOptionals =
    let
        optionals =
            fillOptionals
                { n_member = Absent, n_guest = Absent, n_circle = Absent, n_role = Absent }
    in
    { n_member = optionals.n_member, n_guest = optionals.n_guest, n_circle = optionals.n_circle, n_role = optionals.n_role }


type alias NodeStatsRefOptionalFields =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Type for the NodeStatsRef input object.
-}
type alias NodeStatsRef =
    { n_member : OptionalArgument Int
    , n_guest : OptionalArgument Int
    , n_circle : OptionalArgument Int
    , n_role : OptionalArgument Int
    }


{-| Encode a NodeStatsRef into a value that can be used as an argument.
-}
encodeNodeStatsRef : NodeStatsRef -> Value
encodeNodeStatsRef input =
    Encode.maybeObject
        [ ( "n_member", Encode.int |> Encode.optional input.n_member ), ( "n_guest", Encode.int |> Encode.optional input.n_guest ), ( "n_circle", Encode.int |> Encode.optional input.n_circle ), ( "n_role", Encode.int |> Encode.optional input.n_role ) ]


buildNodeType_hash : NodeType_hashRequiredFields -> NodeType_hash
buildNodeType_hash required =
    { eq = required.eq }


type alias NodeType_hashRequiredFields =
    { eq : Fractal.Enum.NodeType.NodeType }


{-| Type for the NodeType\_hash input object.
-}
type alias NodeType_hash =
    { eq : Fractal.Enum.NodeType.NodeType }


{-| Encode a NodeType\_hash into a value that can be used as an argument.
-}
encodeNodeType_hash : NodeType_hash -> Value
encodeNodeType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeType.toString input.eq |> Just ) ]


buildPostFilter : (PostFilterOptionalFields -> PostFilterOptionalFields) -> PostFilter
buildPostFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodePostFilter |> Encode.optional input.and ), ( "or", encodePostFilter |> Encode.optional input.or ), ( "not", encodePostFilter |> Encode.optional input.not ) ]


buildPostOrder : (PostOrderOptionalFields -> PostOrderOptionalFields) -> PostOrder
buildPostOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.desc ), ( "then", encodePostOrder |> Encode.optional input.then_ ) ]


buildPostPatch : (PostPatchOptionalFields -> PostPatchOptionalFields) -> PostPatch
buildPostPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent }
    in
    PostPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message }


type alias PostPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ) ]


buildPostRef : PostRefRequiredFields -> PostRef
buildPostRef required =
    { id = required.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input.id |> Just ) ]


buildRoleType_hash : (RoleType_hashOptionalFields -> RoleType_hashOptionalFields) -> RoleType_hash
buildRoleType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent }
    in
    { eq = optionals.eq }


type alias RoleType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType }


{-| Type for the RoleType\_hash input object.
-}
type alias RoleType_hash =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType }


{-| Encode a RoleType\_hash into a value that can be used as an argument.
-}
encodeRoleType_hash : RoleType_hash -> Value
encodeRoleType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.eq ) ]


buildStringExactFilter : (StringExactFilterOptionalFields -> StringExactFilterOptionalFields) -> StringExactFilter
buildStringExactFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "le", Encode.string |> Encode.optional input.le ), ( "lt", Encode.string |> Encode.optional input.lt ), ( "ge", Encode.string |> Encode.optional input.ge ), ( "gt", Encode.string |> Encode.optional input.gt ) ]


buildStringFullTextFilter : (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields) -> StringFullTextFilter
buildStringFullTextFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals.alloftext, anyoftext = optionals.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input.anyoftext ) ]


buildStringHashFilter : (StringHashFilterOptionalFields -> StringHashFilterOptionalFields) -> StringHashFilter
buildStringHashFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent }
    in
    { eq = optionals.eq }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ) ]


buildStringHashFilter_StringRegExpFilter : (StringHashFilter_StringRegExpFilterOptionalFields -> StringHashFilter_StringRegExpFilterOptionalFields) -> StringHashFilter_StringRegExpFilter
buildStringHashFilter_StringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, regexp = Absent }
    in
    { eq = optionals.eq, regexp = optionals.regexp }


type alias StringHashFilter_StringRegExpFilterOptionalFields =
    { eq : OptionalArgument String
    , regexp : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringRegExpFilter input object.
-}
type alias StringHashFilter_StringRegExpFilter =
    { eq : OptionalArgument String
    , regexp : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringRegExpFilter : StringHashFilter_StringRegExpFilter -> Value
encodeStringHashFilter_StringRegExpFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringRegExpFilter : (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields) -> StringRegExpFilter
buildStringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { regexp = Absent }
    in
    { regexp = optionals.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringTermFilter : (StringTermFilterOptionalFields -> StringTermFilterOptionalFields) -> StringTermFilter
buildStringTermFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals.allofterms, anyofterms = optionals.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input.anyofterms ) ]


buildTensionFilter : (TensionFilterOptionalFields -> TensionFilterOptionalFields) -> TensionFilter
buildTensionFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitterid = Absent, receiverid = Absent, status = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitterid = optionals.emitterid, receiverid = optionals.receiverid, status = optionals.status, and = optionals.and, or = optionals.or, not = optionals.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , status : OptionalArgument TensionStatus_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , status : OptionalArgument TensionStatus_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "nth", encodeStringTermFilter |> Encode.optional input.nth ), ( "title", encodeStringFullTextFilter |> Encode.optional input.title ), ( "type_", encodeTensionType_hash |> Encode.optional input.type_ ), ( "emitterid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.emitterid ), ( "receiverid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.receiverid ), ( "status", encodeTensionStatus_hash |> Encode.optional input.status ), ( "and", encodeTensionFilter |> Encode.optional input.and ), ( "or", encodeTensionFilter |> Encode.optional input.or ), ( "not", encodeTensionFilter |> Encode.optional input.not ) ]


buildTensionOrder : (TensionOrderOptionalFields -> TensionOrderOptionalFields) -> TensionOrder
buildTensionOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.desc ), ( "then", encodeTensionOrder |> Encode.optional input.then_ ) ]


buildTensionPatch : (TensionPatchOptionalFields -> TensionPatchOptionalFields) -> TensionPatch
buildTensionPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, comments = Absent, labels = Absent, status = Absent, action = Absent, mandate = Absent, n_comments = Absent }
    in
    TensionPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitter = optionals.emitter, emitterid = optionals.emitterid, receiver = optionals.receiver, receiverid = optionals.receiverid, comments = optionals.comments, labels = optionals.labels, status = optionals.status, action = optionals.action, mandate = optionals.mandate, n_comments = optionals.n_comments }


type alias TensionPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildTensionRef : (TensionRefOptionalFields -> TensionRefOptionalFields) -> TensionRef
buildTensionRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, comments = Absent, labels = Absent, status = Absent, action = Absent, mandate = Absent, n_comments = Absent }
    in
    TensionRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitter = optionals.emitter, emitterid = optionals.emitterid, receiver = optionals.receiver, receiverid = optionals.receiverid, comments = optionals.comments, labels = optionals.labels, status = optionals.status, action = optionals.action, mandate = optionals.mandate, n_comments = optionals.n_comments }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , mandate : OptionalArgument MandateRef
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildTensionStatus_hash : TensionStatus_hashRequiredFields -> TensionStatus_hash
buildTensionStatus_hash required =
    { eq = required.eq }


type alias TensionStatus_hashRequiredFields =
    { eq : Fractal.Enum.TensionStatus.TensionStatus }


{-| Type for the TensionStatus\_hash input object.
-}
type alias TensionStatus_hash =
    { eq : Fractal.Enum.TensionStatus.TensionStatus }


{-| Encode a TensionStatus\_hash into a value that can be used as an argument.
-}
encodeTensionStatus_hash : TensionStatus_hash -> Value
encodeTensionStatus_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionStatus.toString input.eq |> Just ) ]


buildTensionType_hash : TensionType_hashRequiredFields -> TensionType_hash
buildTensionType_hash required =
    { eq = required.eq }


type alias TensionType_hashRequiredFields =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString input.eq |> Just ) ]


buildUpdateCommentInput : UpdateCommentInputRequiredFields -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields) -> UpdateCommentInput
buildUpdateCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input.set ), ( "remove", encodeCommentPatch |> Encode.optional input.remove ) ]


buildUpdateLabelInput : UpdateLabelInputRequiredFields -> (UpdateLabelInputOptionalFields -> UpdateLabelInputOptionalFields) -> UpdateLabelInput
buildUpdateLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateLabelInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateLabelInputRequiredFields =
    { filter : LabelFilter }


type alias UpdateLabelInputOptionalFields =
    { set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type alias for the `UpdateLabelInput` attributes. Note that this type
needs to use the `UpdateLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateLabelInputRaw =
    { filter : LabelFilter
    , set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type for the UpdateLabelInput input object.
-}
type UpdateLabelInput
    = UpdateLabelInput UpdateLabelInputRaw


{-| Encode a UpdateLabelInput into a value that can be used as an argument.
-}
encodeUpdateLabelInput : UpdateLabelInput -> Value
encodeUpdateLabelInput (UpdateLabelInput input) =
    Encode.maybeObject
        [ ( "filter", encodeLabelFilter input.filter |> Just ), ( "set", encodeLabelPatch |> Encode.optional input.set ), ( "remove", encodeLabelPatch |> Encode.optional input.remove ) ]


buildUpdateMandateInput : UpdateMandateInputRequiredFields -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields) -> UpdateMandateInput
buildUpdateMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input.set ), ( "remove", encodeMandatePatch |> Encode.optional input.remove ) ]


buildUpdateNodeCharacInput : UpdateNodeCharacInputRequiredFields -> (UpdateNodeCharacInputOptionalFields -> UpdateNodeCharacInputOptionalFields) -> UpdateNodeCharacInput
buildUpdateNodeCharacInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeCharacInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeCharacInputRequiredFields =
    { filter : NodeCharacFilter }


type alias UpdateNodeCharacInputOptionalFields =
    { set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type alias for the `UpdateNodeCharacInput` attributes. Note that this type
needs to use the `UpdateNodeCharacInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeCharacInputRaw =
    { filter : NodeCharacFilter
    , set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type for the UpdateNodeCharacInput input object.
-}
type UpdateNodeCharacInput
    = UpdateNodeCharacInput UpdateNodeCharacInputRaw


{-| Encode a UpdateNodeCharacInput into a value that can be used as an argument.
-}
encodeUpdateNodeCharacInput : UpdateNodeCharacInput -> Value
encodeUpdateNodeCharacInput (UpdateNodeCharacInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeCharacFilter input.filter |> Just ), ( "set", encodeNodeCharacPatch |> Encode.optional input.set ), ( "remove", encodeNodeCharacPatch |> Encode.optional input.remove ) ]


buildUpdateNodeInput : UpdateNodeInputRequiredFields -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields) -> UpdateNodeInput
buildUpdateNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input.set ), ( "remove", encodeNodePatch |> Encode.optional input.remove ) ]


buildUpdatePostInput : UpdatePostInputRequiredFields -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields) -> UpdatePostInput
buildUpdatePostInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input.set ), ( "remove", encodePostPatch |> Encode.optional input.remove ) ]


buildUpdateTensionInput : UpdateTensionInputRequiredFields -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields) -> UpdateTensionInput
buildUpdateTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input.set ), ( "remove", encodeTensionPatch |> Encode.optional input.remove ) ]


buildUpdateUserInput : UpdateUserInputRequiredFields -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields) -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input.set ), ( "remove", encodeUserPatch |> Encode.optional input.remove ) ]


buildUserFilter : (UserFilterOptionalFields -> UserFilterOptionalFields) -> UserFilter
buildUserFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, username = Absent, email = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals.id, username = optionals.username, email = optionals.email, and = optionals.and, or = optionals.or, not = optionals.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "username", encodeStringHashFilter |> Encode.optional input.username ), ( "email", encodeStringHashFilter |> Encode.optional input.email ), ( "and", encodeUserFilter |> Encode.optional input.and ), ( "or", encodeUserFilter |> Encode.optional input.or ), ( "not", encodeUserFilter |> Encode.optional input.not ) ]


buildUserOrder : (UserOrderOptionalFields -> UserOrderOptionalFields) -> UserOrder
buildUserOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserOrder |> Encode.optional input.then_ ) ]


buildUserPatch : (UserPatchOptionalFields -> UserPatchOptionalFields) -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, bio = Absent, utc = Absent }
    in
    UserPatch { createdAt = optionals.createdAt, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio, utc = optionals.utc }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRef : (UserRefOptionalFields -> UserRefOptionalFields) -> UserRef
buildUserRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, username = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, bio = Absent, utc = Absent }
    in
    UserRef { id = optionals.id, createdAt = optionals.createdAt, username = optionals.username, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio, utc = optionals.utc }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "username", Encode.string |> Encode.optional input.username ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRightsRef : (UserRightsRefOptionalFields -> UserRightsRefOptionalFields) -> UserRightsRef
buildUserRightsRef fillOptionals =
    let
        optionals =
            fillOptionals
                { canLogin = Absent, canCreateRoot = Absent }
    in
    { canLogin = optionals.canLogin, canCreateRoot = optionals.canCreateRoot }


type alias UserRightsRefOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    }


{-| Type for the UserRightsRef input object.
-}
type alias UserRightsRef =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    }


{-| Encode a UserRightsRef into a value that can be used as an argument.
-}
encodeUserRightsRef : UserRightsRef -> Value
encodeUserRightsRef input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input.canCreateRoot ) ]
