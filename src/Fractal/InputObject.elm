-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.BlobHasFilter
import Fractal.Enum.BlobOrderable
import Fractal.Enum.BlobType
import Fractal.Enum.CommentHasFilter
import Fractal.Enum.CommentOrderable
import Fractal.Enum.ContractHasFilter
import Fractal.Enum.ContractOrderable
import Fractal.Enum.ContractStatus
import Fractal.Enum.ContractType
import Fractal.Enum.EventFragmentHasFilter
import Fractal.Enum.EventFragmentOrderable
import Fractal.Enum.EventHasFilter
import Fractal.Enum.EventOrderable
import Fractal.Enum.HTTPMethod
import Fractal.Enum.LabelHasFilter
import Fractal.Enum.LabelOrderable
import Fractal.Enum.MandateHasFilter
import Fractal.Enum.MandateOrderable
import Fractal.Enum.Mode
import Fractal.Enum.NodeCharacHasFilter
import Fractal.Enum.NodeFragmentHasFilter
import Fractal.Enum.NodeFragmentOrderable
import Fractal.Enum.NodeHasFilter
import Fractal.Enum.NodeMode
import Fractal.Enum.NodeOrderable
import Fractal.Enum.NodeType
import Fractal.Enum.OrgaAggHasFilter
import Fractal.Enum.OrgaAggOrderable
import Fractal.Enum.PostHasFilter
import Fractal.Enum.PostOrderable
import Fractal.Enum.RoleType
import Fractal.Enum.TensionAction
import Fractal.Enum.TensionEvent
import Fractal.Enum.TensionHasFilter
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionStatus
import Fractal.Enum.TensionType
import Fractal.Enum.UserHasFilter
import Fractal.Enum.UserOrderable
import Fractal.Enum.UserRightsHasFilter
import Fractal.Enum.UserRightsOrderable
import Fractal.Enum.UserType
import Fractal.Enum.VoteHasFilter
import Fractal.Enum.VoteOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddBlobInput :
    AddBlobInputRequiredFields
    -> (AddBlobInputOptionalFields -> AddBlobInputOptionalFields)
    -> AddBlobInput
buildAddBlobInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    AddBlobInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = required.tension, blob_type = required.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias AddBlobInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    }


type alias AddBlobInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `AddBlobInput` attributes. Note that this type
needs to use the `AddBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddBlobInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the AddBlobInput input object.
-}
type AddBlobInput
    = AddBlobInput AddBlobInputRaw


{-| Encode a AddBlobInput into a value that can be used as an argument.
-}
encodeAddBlobInput : AddBlobInput -> Value
encodeAddBlobInput (AddBlobInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef input.tension |> Just ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString input.blob_type |> Just ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildAddCommentInput :
    AddCommentInputRequiredFields
    -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields)
    -> AddCommentInput
buildAddCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, void_ = Absent }
    in
    AddCommentInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias AddCommentInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    }


type alias AddCommentInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildAddContractInput :
    AddContractInputRequiredFields
    -> (AddContractInputOptionalFields -> AddContractInputOptionalFields)
    -> AddContractInput
buildAddContractInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, closedAt = Absent, candidates = Absent, participants = Absent, comments = Absent, isValidator = Absent }
    in
    AddContractInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = required.tension, status = required.status, contract_type = required.contract_type, closedAt = optionals.closedAt, event = required.event, candidates = optionals.candidates, participants = optionals.participants, comments = optionals.comments, isValidator = optionals.isValidator }


type alias AddContractInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , event : EventFragmentRef
    }


type alias AddContractInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `AddContractInput` attributes. Note that this type
needs to use the `AddContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddContractInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : EventFragmentRef
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the AddContractInput input object.
-}
type AddContractInput
    = AddContractInput AddContractInputRaw


{-| Encode a AddContractInput into a value that can be used as an argument.
-}
encodeAddContractInput : AddContractInput -> Value
encodeAddContractInput (AddContractInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef input.tension |> Just ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString input.status |> Just ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString input.contract_type |> Just ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.closedAt ), ( "event", encodeEventFragmentRef input.event |> Just ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input.candidates ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input.participants ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "isValidator", Encode.bool |> Encode.optional input.isValidator ) ]


buildAddEventFragmentInput :
    AddEventFragmentInputRequiredFields
    -> (AddEventFragmentInputOptionalFields -> AddEventFragmentInputOptionalFields)
    -> AddEventFragmentInput
buildAddEventFragmentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { old = Absent, new = Absent }
    in
    { event_type = required.event_type, old = optionals.old, new = optionals.new }


type alias AddEventFragmentInputRequiredFields =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent }


type alias AddEventFragmentInputOptionalFields =
    { old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventFragmentInput input object.
-}
type alias AddEventFragmentInput =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a AddEventFragmentInput into a value that can be used as an argument.
-}
encodeAddEventFragmentInput : AddEventFragmentInput -> Value
encodeAddEventFragmentInput input =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input.event_type |> Just ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildAddEventInput :
    AddEventInputRequiredFields
    -> (AddEventInputOptionalFields -> AddEventInputOptionalFields)
    -> AddEventInput
buildAddEventInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, old = Absent, new = Absent }
    in
    AddEventInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = required.tension, event_type = required.event_type, old = optionals.old, new = optionals.new }


type alias AddEventInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    }


type alias AddEventInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `AddEventInput` attributes. Note that this type
needs to use the `AddEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddEventInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventInput input object.
-}
type AddEventInput
    = AddEventInput AddEventInputRaw


{-| Encode a AddEventInput into a value that can be used as an argument.
-}
encodeAddEventInput : AddEventInput -> Value
encodeAddEventInput (AddEventInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef input.tension |> Just ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input.event_type |> Just ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildAddLabelInput :
    AddLabelInputRequiredFields
    -> (AddLabelInputOptionalFields -> AddLabelInputOptionalFields)
    -> AddLabelInput
buildAddLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    AddLabelInput { rootnameid = required.rootnameid, name = required.name, description = optionals.description, color = optionals.color, tensions = optionals.tensions, nodes = optionals.nodes, n_nodes = optionals.n_nodes, n_tensions = optionals.n_tensions }


type alias AddLabelInputRequiredFields =
    { rootnameid : String
    , name : String
    }


type alias AddLabelInputOptionalFields =
    { description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `AddLabelInput` attributes. Note that this type
needs to use the `AddLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddLabelInputRaw =
    { rootnameid : String
    , name : String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the AddLabelInput input object.
-}
type AddLabelInput
    = AddLabelInput AddLabelInputRaw


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput (AddLabelInput input) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string input.rootnameid |> Just ), ( "name", Encode.string input.name |> Just ), ( "description", Encode.string |> Encode.optional input.description ), ( "color", Encode.string |> Encode.optional input.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input.nodes ), ( "n_nodes", Encode.int |> Encode.optional input.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input.n_tensions ) ]


buildAddMandateInput :
    AddMandateInputRequiredFields
    -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields)
    -> AddMandateInput
buildAddMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = required.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias AddMandateInputRequiredFields =
    { purpose : String }


type alias AddMandateInputOptionalFields =
    { responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the AddMandateInput input object.
-}
type alias AddMandateInput =
    { purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput input =
    Encode.maybeObject
        [ ( "purpose", Encode.string input.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildAddNodeCharacInput :
    AddNodeCharacInputRequiredFields
    -> AddNodeCharacInput
buildAddNodeCharacInput required =
    { userCanJoin = required.userCanJoin, mode = required.mode }


type alias AddNodeCharacInputRequiredFields =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the AddNodeCharacInput input object.
-}
type alias AddNodeCharacInput =
    { userCanJoin : Bool
    , mode : Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a AddNodeCharacInput into a value that can be used as an argument.
-}
encodeAddNodeCharacInput : AddNodeCharacInput -> Value
encodeAddNodeCharacInput input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool input.userCanJoin |> Just ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString input.mode |> Just ) ]


buildAddNodeFragmentInput :
    (AddNodeFragmentInputOptionalFields -> AddNodeFragmentInputOptionalFields)
    -> AddNodeFragmentInput
buildAddNodeFragmentInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    AddNodeFragmentInput { name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias AddNodeFragmentInputOptionalFields =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `AddNodeFragmentInput` attributes. Note that this type
needs to use the `AddNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeFragmentInputRaw =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the AddNodeFragmentInput input object.
-}
type AddNodeFragmentInput
    = AddNodeFragmentInput AddNodeFragmentInputRaw


{-| Encode a AddNodeFragmentInput into a value that can be used as an argument.
-}
encodeAddNodeFragmentInput : AddNodeFragmentInput -> Value
encodeAddNodeFragmentInput (AddNodeFragmentInput input) =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildAddNodeInput :
    AddNodeInputRequiredFields
    -> (AddNodeInputOptionalFields -> AddNodeInputOptionalFields)
    -> AddNodeInput
buildAddNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, parent = Absent, children = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, isPersonal = Absent, labels = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, contracts = Absent, orga_agg = Absent }
    in
    AddNodeInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, name = required.name, nameid = required.nameid, rootnameid = required.rootnameid, parent = optionals.parent, children = optionals.children, type_ = required.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, isRoot = required.isRoot, isPersonal = optionals.isPersonal, isPrivate = required.isPrivate, isArchived = required.isArchived, charac = required.charac, rights = required.rights, labels = optionals.labels, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, contracts = optionals.contracts, orga_agg = optionals.orga_agg }


type alias AddNodeInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , type_ : Fractal.Enum.NodeType.NodeType
    , isRoot : Bool
    , isPrivate : Bool
    , isArchived : Bool
    , charac : NodeCharacRef
    , rights : Int
    }


type alias AddNodeInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isPersonal : OptionalArgument Bool
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `AddNodeInput` attributes. Note that this type
needs to use the `AddNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isRoot : Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : Bool
    , isArchived : Bool
    , charac : NodeCharacRef
    , rights : Int
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the AddNodeInput input object.
-}
type AddNodeInput
    = AddNodeInput AddNodeInputRaw


{-| Encode a AddNodeInput into a value that can be used as an argument.
-}
encodeAddNodeInput : AddNodeInput -> Value
encodeAddNodeInput (AddNodeInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string input.name |> Just ), ( "nameid", Encode.string input.nameid |> Just ), ( "rootnameid", Encode.string input.rootnameid |> Just ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString input.type_ |> Just ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "isRoot", Encode.bool input.isRoot |> Just ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool input.isPrivate |> Just ), ( "isArchived", Encode.bool input.isArchived |> Just ), ( "charac", encodeNodeCharacRef input.charac |> Just ), ( "rights", Encode.int input.rights |> Just ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input.orga_agg ) ]


buildAddOrgaAggInput :
    (AddOrgaAggInputOptionalFields -> AddOrgaAggInputOptionalFields)
    -> AddOrgaAggInput
buildAddOrgaAggInput fillOptionals =
    let
        optionals =
            fillOptionals
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals.n_members, n_guests = optionals.n_guests }


type alias AddOrgaAggInputOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the AddOrgaAggInput input object.
-}
type alias AddOrgaAggInput =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a AddOrgaAggInput into a value that can be used as an argument.
-}
encodeAddOrgaAggInput : AddOrgaAggInput -> Value
encodeAddOrgaAggInput input =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input.n_members ), ( "n_guests", Encode.int |> Encode.optional input.n_guests ) ]


buildAddTensionInput :
    AddTensionInputRequiredFields
    -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields)
    -> AddTensionInput
buildAddTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, nth = Absent, assignees = Absent, labels = Absent, comments = Absent, action = Absent, blobs = Absent, contracts = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    AddTensionInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, emitterid = required.emitterid, emitter = required.emitter, receiverid = required.receiverid, receiver = required.receiver, nth = optionals.nth, title = required.title, type_ = required.type_, status = required.status, assignees = optionals.assignees, labels = optionals.labels, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, contracts = optionals.contracts, history = required.history, n_comments = optionals.n_comments, n_open_contracts = optionals.n_open_contracts }


type alias AddTensionInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , emitterid : String
    , emitter : NodeRef
    , receiverid : String
    , receiver : NodeRef
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , history : List EventRef
    }


type alias AddTensionInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , nth : OptionalArgument String
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitterid : String
    , emitter : NodeRef
    , receiverid : String
    , receiver : NodeRef
    , nth : OptionalArgument String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , history : List EventRef
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "emitterid", Encode.string input.emitterid |> Just ), ( "emitter", encodeNodeRef input.emitter |> Just ), ( "receiverid", Encode.string input.receiverid |> Just ), ( "receiver", encodeNodeRef input.receiver |> Just ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string input.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input.type_ |> Just ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString input.status |> Just ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "history", (encodeEventRef |> Encode.list) input.history |> Just ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input.n_open_contracts ) ]


buildAddUserInput :
    AddUserInputRequiredFields
    -> (AddUserInputOptionalFields -> AddUserInputOptionalFields)
    -> AddUserInput
buildAddUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, emailHash = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, bio = Absent, utc = Absent }
    in
    AddUserInput { createdAt = required.createdAt, lastAck = required.lastAck, username = required.username, name = optionals.name, password = required.password, email = required.email, emailHash = optionals.emailHash, emailValidated = required.emailValidated, rights = required.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, contracts = optionals.contracts, bio = optionals.bio, utc = optionals.utc }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , password : String
    , email : String
    , emailValidated : Bool
    , rights : UserRightsRef
    }


type alias AddUserInputOptionalFields =
    { name : OptionalArgument String
    , emailHash : OptionalArgument String
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , name : OptionalArgument String
    , password : String
    , email : String
    , emailHash : OptionalArgument String
    , emailValidated : Bool
    , rights : UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.lastAck |> Just ), ( "username", Encode.string input.username |> Just ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string input.password |> Just ), ( "email", Encode.string input.email |> Just ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool input.emailValidated |> Just ), ( "rights", encodeUserRightsRef input.rights |> Just ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildAddUserRightsInput :
    AddUserRightsInputRequiredFields
    -> AddUserRightsInput
buildAddUserRightsInput required =
    { canLogin = required.canLogin, canCreateRoot = required.canCreateRoot, maxPublicOrga = required.maxPublicOrga, type_ = required.type_ }


type alias AddUserRightsInputRequiredFields =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , type_ : Fractal.Enum.UserType.UserType
    }


{-| Type for the AddUserRightsInput input object.
-}
type alias AddUserRightsInput =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , type_ : Fractal.Enum.UserType.UserType
    }


{-| Encode a AddUserRightsInput into a value that can be used as an argument.
-}
encodeAddUserRightsInput : AddUserRightsInput -> Value
encodeAddUserRightsInput input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool input.canLogin |> Just ), ( "canCreateRoot", Encode.bool input.canCreateRoot |> Just ), ( "maxPublicOrga", Encode.int input.maxPublicOrga |> Just ), ( "type_", Encode.enum Fractal.Enum.UserType.toString input.type_ |> Just ) ]


buildAddVoteInput :
    AddVoteInputRequiredFields
    -> (AddVoteInputOptionalFields -> AddVoteInputOptionalFields)
    -> AddVoteInput
buildAddVoteInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { updatedAt = Absent, message = Absent, data = Absent }
    in
    AddVoteInput { createdBy = required.createdBy, createdAt = required.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, voteId = required.voteId, contract = required.contract, node = required.node, data = optionals.data }


type alias AddVoteInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , voteId : String
    , contract : ContractRef
    , node : NodeRef
    }


type alias AddVoteInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `AddVoteInput` attributes. Note that this type
needs to use the `AddVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddVoteInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteId : String
    , contract : ContractRef
    , node : NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the AddVoteInput input object.
-}
type AddVoteInput
    = AddVoteInput AddVoteInputRaw


{-| Encode a AddVoteInput into a value that can be used as an argument.
-}
encodeAddVoteInput : AddVoteInput -> Value
encodeAddVoteInput (AddVoteInput input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "voteId", Encode.string input.voteId |> Just ), ( "contract", encodeContractRef input.contract |> Just ), ( "node", encodeNodeRef input.node |> Just ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input.data ) ]


buildAuthRule :
    (AuthRuleOptionalFields -> AuthRuleOptionalFields)
    -> AuthRule
buildAuthRule fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, rule = Absent }
    in
    AuthRule { and = optionals.and, or = optionals.or, not = optionals.not, rule = optionals.rule }


type alias AuthRuleOptionalFields =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type alias for the `AuthRule` attributes. Note that this type
needs to use the `AuthRule` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AuthRuleRaw =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type for the AuthRule input object.
-}
type AuthRule
    = AuthRule AuthRuleRaw


{-| Encode a AuthRule into a value that can be used as an argument.
-}
encodeAuthRule : AuthRule -> Value
encodeAuthRule (AuthRule input) =
    Encode.maybeObject
        [ ( "and", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeAuthRule |> Encode.optional input.not ), ( "rule", Encode.string |> Encode.optional input.rule ) ]


buildBlobFilter :
    (BlobFilterOptionalFields -> BlobFilterOptionalFields)
    -> BlobFilter
buildBlobFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    BlobFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias BlobFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type alias for the `BlobFilter` attributes. Note that this type
needs to use the `BlobFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type for the BlobFilter input object.
-}
type BlobFilter
    = BlobFilter BlobFilterRaw


{-| Encode a BlobFilter into a value that can be used as an argument.
-}
encodeBlobFilter : BlobFilter -> Value
encodeBlobFilter (BlobFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "blob_type", encodeBlobType_hash |> Encode.optional input.blob_type ), ( "pushedFlag", encodeDateTimeFilter |> Encode.optional input.pushedFlag ), ( "archivedFlag", encodeDateTimeFilter |> Encode.optional input.archivedFlag ), ( "has", (Encode.enum Fractal.Enum.BlobHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeBlobFilter |> Encode.optional input.not ) ]


buildBlobOrder :
    (BlobOrderOptionalFields -> BlobOrderOptionalFields)
    -> BlobOrder
buildBlobOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    BlobOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias BlobOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type alias for the `BlobOrder` attributes. Note that this type
needs to use the `BlobOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobOrderRaw =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type for the BlobOrder input object.
-}
type BlobOrder
    = BlobOrder BlobOrderRaw


{-| Encode a BlobOrder into a value that can be used as an argument.
-}
encodeBlobOrder : BlobOrder -> Value
encodeBlobOrder (BlobOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input.desc ), ( "then", encodeBlobOrder |> Encode.optional input.then_ ) ]


buildBlobPatch :
    (BlobPatchOptionalFields -> BlobPatchOptionalFields)
    -> BlobPatch
buildBlobPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias BlobPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobPatch` attributes. Note that this type
needs to use the `BlobPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobPatch input object.
-}
type BlobPatch
    = BlobPatch BlobPatchRaw


{-| Encode a BlobPatch into a value that can be used as an argument.
-}
encodeBlobPatch : BlobPatch -> Value
encodeBlobPatch (BlobPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildBlobRef :
    (BlobRefOptionalFields -> BlobRefOptionalFields)
    -> BlobRef
buildBlobRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, blob_type = optionals.blob_type, pushedFlag = optionals.pushedFlag, archivedFlag = optionals.archivedFlag, node = optionals.node, md = optionals.md }


type alias BlobRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobRef` attributes. Note that this type
needs to use the `BlobRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobRef input object.
-}
type BlobRef
    = BlobRef BlobRefRaw


{-| Encode a BlobRef into a value that can be used as an argument.
-}
encodeBlobRef : BlobRef -> Value
encodeBlobRef (BlobRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input.node ), ( "md", Encode.string |> Encode.optional input.md ) ]


buildBlobType_hash :
    (BlobType_hashOptionalFields -> BlobType_hashOptionalFields)
    -> BlobType_hash
buildBlobType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias BlobType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Type for the BlobType\_hash input object.
-}
type alias BlobType_hash =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Encode a BlobType\_hash into a value that can be used as an argument.
-}
encodeBlobType_hash : BlobType_hash -> Value
encodeBlobType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.BlobType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildCommentFilter :
    (CommentFilterOptionalFields -> CommentFilterOptionalFields)
    -> CommentFilter
buildCommentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "has", (Encode.enum Fractal.Enum.CommentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeCommentFilter |> Encode.optional input.not ) ]


buildCommentOrder :
    (CommentOrderOptionalFields -> CommentOrderOptionalFields)
    -> CommentOrder
buildCommentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeCommentOrder |> Encode.optional input.then_ ) ]


buildCommentPatch :
    (CommentPatchOptionalFields -> CommentPatchOptionalFields)
    -> CommentPatch
buildCommentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias CommentPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCommentRef :
    (CommentRefOptionalFields -> CommentRefOptionalFields)
    -> CommentRef
buildCommentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, void_ = optionals.void_ }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildContainsFilter :
    (ContainsFilterOptionalFields -> ContainsFilterOptionalFields)
    -> ContainsFilter
buildContainsFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { point = Absent, polygon = Absent }
    in
    ContainsFilter { point = optionals.point, polygon = optionals.polygon }


type alias ContainsFilterOptionalFields =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Type alias for the `ContainsFilter` attributes. Note that this type
needs to use the `ContainsFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContainsFilterRaw =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Type for the ContainsFilter input object.
-}
type ContainsFilter
    = ContainsFilter ContainsFilterRaw


{-| Encode a ContainsFilter into a value that can be used as an argument.
-}
encodeContainsFilter : ContainsFilter -> Value
encodeContainsFilter (ContainsFilter input) =
    Encode.maybeObject
        [ ( "point", encodePointRef |> Encode.optional input.point ), ( "polygon", encodePolygonRef |> Encode.optional input.polygon ) ]


buildContractFilter :
    (ContractFilterOptionalFields -> ContractFilterOptionalFields)
    -> ContractFilter
buildContractFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, status = Absent, contract_type = Absent, closedAt = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ContractFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, status = optionals.status, contract_type = optionals.contract_type, closedAt = optionals.closedAt, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias ContractFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type alias for the `ContractFilter` attributes. Note that this type
needs to use the `ContractFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type for the ContractFilter input object.
-}
type ContractFilter
    = ContractFilter ContractFilterRaw


{-| Encode a ContractFilter into a value that can be used as an argument.
-}
encodeContractFilter : ContractFilter -> Value
encodeContractFilter (ContractFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "status", encodeContractStatus_hash |> Encode.optional input.status ), ( "contract_type", encodeContractType_hash |> Encode.optional input.contract_type ), ( "closedAt", encodeDateTimeFilter |> Encode.optional input.closedAt ), ( "has", (Encode.enum Fractal.Enum.ContractHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeContractFilter |> Encode.optional input.not ) ]


buildContractOrder :
    (ContractOrderOptionalFields -> ContractOrderOptionalFields)
    -> ContractOrder
buildContractOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ContractOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias ContractOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type alias for the `ContractOrder` attributes. Note that this type
needs to use the `ContractOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type for the ContractOrder input object.
-}
type ContractOrder
    = ContractOrder ContractOrderRaw


{-| Encode a ContractOrder into a value that can be used as an argument.
-}
encodeContractOrder : ContractOrder -> Value
encodeContractOrder (ContractOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input.desc ), ( "then", encodeContractOrder |> Encode.optional input.then_ ) ]


buildContractPatch :
    (ContractPatchOptionalFields -> ContractPatchOptionalFields)
    -> ContractPatch
buildContractPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, candidates = Absent, participants = Absent, comments = Absent, isValidator = Absent }
    in
    ContractPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, status = optionals.status, contract_type = optionals.contract_type, closedAt = optionals.closedAt, event = optionals.event, candidates = optionals.candidates, participants = optionals.participants, comments = optionals.comments, isValidator = optionals.isValidator }


type alias ContractPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractPatch` attributes. Note that this type
needs to use the `ContractPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractPatch input object.
-}
type ContractPatch
    = ContractPatch ContractPatchRaw


{-| Encode a ContractPatch into a value that can be used as an argument.
-}
encodeContractPatch : ContractPatch -> Value
encodeContractPatch (ContractPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input.event ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input.candidates ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input.participants ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "isValidator", Encode.bool |> Encode.optional input.isValidator ) ]


buildContractRef :
    (ContractRefOptionalFields -> ContractRefOptionalFields)
    -> ContractRef
buildContractRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, candidates = Absent, participants = Absent, comments = Absent, isValidator = Absent }
    in
    ContractRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, status = optionals.status, contract_type = optionals.contract_type, closedAt = optionals.closedAt, event = optionals.event, candidates = optionals.candidates, participants = optionals.participants, comments = optionals.comments, isValidator = optionals.isValidator }


type alias ContractRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractRef` attributes. Note that this type
needs to use the `ContractRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , candidates : OptionalArgument (List UserRef)
    , participants : OptionalArgument (List VoteRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractRef input object.
-}
type ContractRef
    = ContractRef ContractRefRaw


{-| Encode a ContractRef into a value that can be used as an argument.
-}
encodeContractRef : ContractRef -> Value
encodeContractRef (ContractRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input.event ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input.candidates ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input.participants ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "isValidator", Encode.bool |> Encode.optional input.isValidator ) ]


buildContractStatus_hash :
    (ContractStatus_hashOptionalFields -> ContractStatus_hashOptionalFields)
    -> ContractStatus_hash
buildContractStatus_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias ContractStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Type for the ContractStatus\_hash input object.
-}
type alias ContractStatus_hash =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Encode a ContractStatus\_hash into a value that can be used as an argument.
-}
encodeContractStatus_hash : ContractStatus_hash -> Value
encodeContractStatus_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildContractType_hash :
    (ContractType_hashOptionalFields -> ContractType_hashOptionalFields)
    -> ContractType_hash
buildContractType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias ContractType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Type for the ContractType\_hash input object.
-}
type alias ContractType_hash =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Encode a ContractType\_hash into a value that can be used as an argument.
-}
encodeContractType_hash : ContractType_hash -> Value
encodeContractType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.ContractType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildCustomHTTP :
    CustomHTTPRequiredFields
    -> (CustomHTTPOptionalFields -> CustomHTTPOptionalFields)
    -> CustomHTTP
buildCustomHTTP required fillOptionals =
    let
        optionals =
            fillOptionals
                { body = Absent, graphql = Absent, mode = Absent, forwardHeaders = Absent, secretHeaders = Absent, introspectionHeaders = Absent, skipIntrospection = Absent }
    in
    { url = required.url, method = required.method, body = optionals.body, graphql = optionals.graphql, mode = optionals.mode, forwardHeaders = optionals.forwardHeaders, secretHeaders = optionals.secretHeaders, introspectionHeaders = optionals.introspectionHeaders, skipIntrospection = optionals.skipIntrospection }


type alias CustomHTTPRequiredFields =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    }


type alias CustomHTTPOptionalFields =
    { body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Type for the CustomHTTP input object.
-}
type alias CustomHTTP =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    , body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Encode a CustomHTTP into a value that can be used as an argument.
-}
encodeCustomHTTP : CustomHTTP -> Value
encodeCustomHTTP input =
    Encode.maybeObject
        [ ( "url", Encode.string input.url |> Just ), ( "method", Encode.enum Fractal.Enum.HTTPMethod.toString input.method |> Just ), ( "body", Encode.string |> Encode.optional input.body ), ( "graphql", Encode.string |> Encode.optional input.graphql ), ( "mode", Encode.enum Fractal.Enum.Mode.toString |> Encode.optional input.mode ), ( "forwardHeaders", (Encode.string |> Encode.list) |> Encode.optional input.forwardHeaders ), ( "secretHeaders", (Encode.string |> Encode.list) |> Encode.optional input.secretHeaders ), ( "introspectionHeaders", (Encode.string |> Encode.list) |> Encode.optional input.introspectionHeaders ), ( "skipIntrospection", Encode.bool |> Encode.optional input.skipIntrospection ) ]


buildDateTimeFilter :
    (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields)
    -> DateTimeFilter
buildDateTimeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt, between = optionals.between }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.gt ), ( "between", encodeDateTimeRange |> Encode.optional input.between ) ]


buildDateTimeRange :
    DateTimeRangeRequiredFields
    -> DateTimeRange
buildDateTimeRange required =
    { min = required.min, max = required.max }


type alias DateTimeRangeRequiredFields =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeRange input object.
-}
type alias DateTimeRange =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeRange into a value that can be used as an argument.
-}
encodeDateTimeRange : DateTimeRange -> Value
encodeDateTimeRange input =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.max |> Just ) ]


buildEventFilter :
    (EventFilterOptionalFields -> EventFilterOptionalFields)
    -> EventFilter
buildEventFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, event_type = optionals.event_type, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias EventFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type alias for the `EventFilter` attributes. Note that this type
needs to use the `EventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type for the EventFilter input object.
-}
type EventFilter
    = EventFilter EventFilterRaw


{-| Encode a EventFilter into a value that can be used as an argument.
-}
encodeEventFilter : EventFilter -> Value
encodeEventFilter (EventFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "event_type", encodeTensionEvent_hash |> Encode.optional input.event_type ), ( "has", (Encode.enum Fractal.Enum.EventHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeEventFilter |> Encode.optional input.not ) ]


buildEventFragmentFilter :
    (EventFragmentFilterOptionalFields -> EventFragmentFilterOptionalFields)
    -> EventFragmentFilter
buildEventFragmentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFragmentFilter { event_type = optionals.event_type, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias EventFragmentFilterOptionalFields =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type alias for the `EventFragmentFilter` attributes. Note that this type
needs to use the `EventFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentFilterRaw =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type for the EventFragmentFilter input object.
-}
type EventFragmentFilter
    = EventFragmentFilter EventFragmentFilterRaw


{-| Encode a EventFragmentFilter into a value that can be used as an argument.
-}
encodeEventFragmentFilter : EventFragmentFilter -> Value
encodeEventFragmentFilter (EventFragmentFilter input) =
    Encode.maybeObject
        [ ( "event_type", encodeTensionEvent_hash |> Encode.optional input.event_type ), ( "has", (Encode.enum Fractal.Enum.EventFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeEventFragmentFilter |> Encode.optional input.not ) ]


buildEventFragmentOrder :
    (EventFragmentOrderOptionalFields -> EventFragmentOrderOptionalFields)
    -> EventFragmentOrder
buildEventFragmentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventFragmentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias EventFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type alias for the `EventFragmentOrder` attributes. Note that this type
needs to use the `EventFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type for the EventFragmentOrder input object.
-}
type EventFragmentOrder
    = EventFragmentOrder EventFragmentOrderRaw


{-| Encode a EventFragmentOrder into a value that can be used as an argument.
-}
encodeEventFragmentOrder : EventFragmentOrder -> Value
encodeEventFragmentOrder (EventFragmentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeEventFragmentOrder |> Encode.optional input.then_ ) ]


buildEventFragmentPatch :
    (EventFragmentPatchOptionalFields -> EventFragmentPatchOptionalFields)
    -> EventFragmentPatch
buildEventFragmentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventFragmentPatchOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentPatch input object.
-}
type alias EventFragmentPatch =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentPatch into a value that can be used as an argument.
-}
encodeEventFragmentPatch : EventFragmentPatch -> Value
encodeEventFragmentPatch input =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildEventFragmentRef :
    (EventFragmentRefOptionalFields -> EventFragmentRefOptionalFields)
    -> EventFragmentRef
buildEventFragmentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventFragmentRefOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentRef input object.
-}
type alias EventFragmentRef =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentRef into a value that can be used as an argument.
-}
encodeEventFragmentRef : EventFragmentRef -> Value
encodeEventFragmentRef input =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildEventOrder :
    (EventOrderOptionalFields -> EventOrderOptionalFields)
    -> EventOrder
buildEventOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias EventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type alias for the `EventOrder` attributes. Note that this type
needs to use the `EventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type for the EventOrder input object.
-}
type EventOrder
    = EventOrder EventOrderRaw


{-| Encode a EventOrder into a value that can be used as an argument.
-}
encodeEventOrder : EventOrder -> Value
encodeEventOrder (EventOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input.desc ), ( "then", encodeEventOrder |> Encode.optional input.then_ ) ]


buildEventPatch :
    (EventPatchOptionalFields -> EventPatchOptionalFields)
    -> EventPatch
buildEventPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventPatch` attributes. Note that this type
needs to use the `EventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventPatch input object.
-}
type EventPatch
    = EventPatch EventPatchRaw


{-| Encode a EventPatch into a value that can be used as an argument.
-}
encodeEventPatch : EventPatch -> Value
encodeEventPatch (EventPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildEventRef :
    (EventRefOptionalFields -> EventRefOptionalFields)
    -> EventRef
buildEventRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, tension = optionals.tension, event_type = optionals.event_type, old = optionals.old, new = optionals.new }


type alias EventRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventRef` attributes. Note that this type
needs to use the `EventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventRef input object.
-}
type EventRef
    = EventRef EventRefRaw


{-| Encode a EventRef into a value that can be used as an argument.
-}
encodeEventRef : EventRef -> Value
encodeEventRef (EventRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "tension", encodeTensionRef |> Encode.optional input.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.event_type ), ( "old", Encode.string |> Encode.optional input.old ), ( "new", Encode.string |> Encode.optional input.new ) ]


buildFloatFilter :
    (FloatFilterOptionalFields -> FloatFilterOptionalFields)
    -> FloatFilter
buildFloatFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt, between = optionals.between }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input.eq ), ( "in", (Encode.float |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "le", Encode.float |> Encode.optional input.le ), ( "lt", Encode.float |> Encode.optional input.lt ), ( "ge", Encode.float |> Encode.optional input.ge ), ( "gt", Encode.float |> Encode.optional input.gt ), ( "between", encodeFloatRange |> Encode.optional input.between ) ]


buildFloatRange :
    FloatRangeRequiredFields
    -> FloatRange
buildFloatRange required =
    { min = required.min, max = required.max }


type alias FloatRangeRequiredFields =
    { min : Float
    , max : Float
    }


{-| Type for the FloatRange input object.
-}
type alias FloatRange =
    { min : Float
    , max : Float
    }


{-| Encode a FloatRange into a value that can be used as an argument.
-}
encodeFloatRange : FloatRange -> Value
encodeFloatRange input =
    Encode.maybeObject
        [ ( "min", Encode.float input.min |> Just ), ( "max", Encode.float input.max |> Just ) ]


buildGenerateMutationParams :
    (GenerateMutationParamsOptionalFields -> GenerateMutationParamsOptionalFields)
    -> GenerateMutationParams
buildGenerateMutationParams fillOptionals =
    let
        optionals =
            fillOptionals
                { add = Absent, update = Absent, delete = Absent }
    in
    { add = optionals.add, update = optionals.update, delete = optionals.delete }


type alias GenerateMutationParamsOptionalFields =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Type for the GenerateMutationParams input object.
-}
type alias GenerateMutationParams =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Encode a GenerateMutationParams into a value that can be used as an argument.
-}
encodeGenerateMutationParams : GenerateMutationParams -> Value
encodeGenerateMutationParams input =
    Encode.maybeObject
        [ ( "add", Encode.bool |> Encode.optional input.add ), ( "update", Encode.bool |> Encode.optional input.update ), ( "delete", Encode.bool |> Encode.optional input.delete ) ]


buildGenerateQueryParams :
    (GenerateQueryParamsOptionalFields -> GenerateQueryParamsOptionalFields)
    -> GenerateQueryParams
buildGenerateQueryParams fillOptionals =
    let
        optionals =
            fillOptionals
                { get = Absent, query = Absent, password = Absent, aggregate = Absent }
    in
    { get = optionals.get, query = optionals.query, password = optionals.password, aggregate = optionals.aggregate }


type alias GenerateQueryParamsOptionalFields =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Type for the GenerateQueryParams input object.
-}
type alias GenerateQueryParams =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Encode a GenerateQueryParams into a value that can be used as an argument.
-}
encodeGenerateQueryParams : GenerateQueryParams -> Value
encodeGenerateQueryParams input =
    Encode.maybeObject
        [ ( "get", Encode.bool |> Encode.optional input.get ), ( "query", Encode.bool |> Encode.optional input.query ), ( "password", Encode.bool |> Encode.optional input.password ), ( "aggregate", Encode.bool |> Encode.optional input.aggregate ) ]


buildInt64Filter :
    (Int64FilterOptionalFields -> Int64FilterOptionalFields)
    -> Int64Filter
buildInt64Filter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt, between = optionals.between }


type alias Int64FilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Type for the Int64Filter input object.
-}
type alias Int64Filter =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Encode a Int64Filter into a value that can be used as an argument.
-}
encodeInt64Filter : Int64Filter -> Value
encodeInt64Filter input =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input.gt ), ( "between", encodeInt64Range |> Encode.optional input.between ) ]


buildInt64Range :
    Int64RangeRequiredFields
    -> Int64Range
buildInt64Range required =
    { min = required.min, max = required.max }


type alias Int64RangeRequiredFields =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Type for the Int64Range input object.
-}
type alias Int64Range =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Encode a Int64Range into a value that can be used as an argument.
-}
encodeInt64Range : Int64Range -> Value
encodeInt64Range input =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input.max |> Just ) ]


buildIntFilter :
    (IntFilterOptionalFields -> IntFilterOptionalFields)
    -> IntFilter
buildIntFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt, between = optionals.between }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input.eq ), ( "in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "le", Encode.int |> Encode.optional input.le ), ( "lt", Encode.int |> Encode.optional input.lt ), ( "ge", Encode.int |> Encode.optional input.ge ), ( "gt", Encode.int |> Encode.optional input.gt ), ( "between", encodeIntRange |> Encode.optional input.between ) ]


buildIntRange :
    IntRangeRequiredFields
    -> IntRange
buildIntRange required =
    { min = required.min, max = required.max }


type alias IntRangeRequiredFields =
    { min : Int
    , max : Int
    }


{-| Type for the IntRange input object.
-}
type alias IntRange =
    { min : Int
    , max : Int
    }


{-| Encode a IntRange into a value that can be used as an argument.
-}
encodeIntRange : IntRange -> Value
encodeIntRange input =
    Encode.maybeObject
        [ ( "min", Encode.int input.min |> Just ), ( "max", Encode.int input.max |> Just ) ]


buildIntersectsFilter :
    (IntersectsFilterOptionalFields -> IntersectsFilterOptionalFields)
    -> IntersectsFilter
buildIntersectsFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { polygon = Absent, multiPolygon = Absent }
    in
    IntersectsFilter { polygon = optionals.polygon, multiPolygon = optionals.multiPolygon }


type alias IntersectsFilterOptionalFields =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Type alias for the `IntersectsFilter` attributes. Note that this type
needs to use the `IntersectsFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias IntersectsFilterRaw =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Type for the IntersectsFilter input object.
-}
type IntersectsFilter
    = IntersectsFilter IntersectsFilterRaw


{-| Encode a IntersectsFilter into a value that can be used as an argument.
-}
encodeIntersectsFilter : IntersectsFilter -> Value
encodeIntersectsFilter (IntersectsFilter input) =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef |> Encode.optional input.polygon ), ( "multiPolygon", encodeMultiPolygonRef |> Encode.optional input.multiPolygon ) ]


buildLabelFilter :
    (LabelFilterOptionalFields -> LabelFilterOptionalFields)
    -> LabelFilter
buildLabelFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, rootnameid = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals.id, rootnameid = optionals.rootnameid, name = optionals.name, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input.rootnameid ), ( "name", encodeStringHashFilter_StringTermFilter |> Encode.optional input.name ), ( "has", (Encode.enum Fractal.Enum.LabelHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeLabelFilter |> Encode.optional input.not ) ]


buildLabelOrder :
    (LabelOrderOptionalFields -> LabelOrderOptionalFields)
    -> LabelOrder
buildLabelOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.desc ), ( "then", encodeLabelOrder |> Encode.optional input.then_ ) ]


buildLabelPatch :
    (LabelPatchOptionalFields -> LabelPatchOptionalFields)
    -> LabelPatch
buildLabelPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    LabelPatch { rootnameid = optionals.rootnameid, name = optionals.name, description = optionals.description, color = optionals.color, tensions = optionals.tensions, nodes = optionals.nodes, n_nodes = optionals.n_nodes, n_tensions = optionals.n_tensions }


type alias LabelPatchOptionalFields =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `LabelPatch` attributes. Note that this type
needs to use the `LabelPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelPatchRaw =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the LabelPatch input object.
-}
type LabelPatch
    = LabelPatch LabelPatchRaw


{-| Encode a LabelPatch into a value that can be used as an argument.
-}
encodeLabelPatch : LabelPatch -> Value
encodeLabelPatch (LabelPatch input) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "name", Encode.string |> Encode.optional input.name ), ( "description", Encode.string |> Encode.optional input.description ), ( "color", Encode.string |> Encode.optional input.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input.nodes ), ( "n_nodes", Encode.int |> Encode.optional input.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input.n_tensions ) ]


buildLabelRef :
    (LabelRefOptionalFields -> LabelRefOptionalFields)
    -> LabelRef
buildLabelRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    LabelRef { id = optionals.id, rootnameid = optionals.rootnameid, name = optionals.name, description = optionals.description, color = optionals.color, tensions = optionals.tensions, nodes = optionals.nodes, n_nodes = optionals.n_nodes, n_tensions = optionals.n_tensions }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `LabelRef` attributes. Note that this type
needs to use the `LabelRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the LabelRef input object.
-}
type LabelRef
    = LabelRef LabelRefRaw


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef (LabelRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "name", Encode.string |> Encode.optional input.name ), ( "description", Encode.string |> Encode.optional input.description ), ( "color", Encode.string |> Encode.optional input.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input.nodes ), ( "n_nodes", Encode.int |> Encode.optional input.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input.n_tensions ) ]


buildMandateFilter :
    (MandateFilterOptionalFields -> MandateFilterOptionalFields)
    -> MandateFilter
buildMandateFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, purpose = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals.id, purpose = optionals.purpose, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input.purpose ), ( "has", (Encode.enum Fractal.Enum.MandateHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeMandateFilter |> Encode.optional input.not ) ]


buildMandateOrder :
    (MandateOrderOptionalFields -> MandateOrderOptionalFields)
    -> MandateOrder
buildMandateOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.desc ), ( "then", encodeMandateOrder |> Encode.optional input.then_ ) ]


buildMandatePatch :
    (MandatePatchOptionalFields -> MandatePatchOptionalFields)
    -> MandatePatch
buildMandatePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandatePatchOptionalFields =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandatePatch input object.
-}
type alias MandatePatch =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch input =
    Encode.maybeObject
        [ ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildMandateRef :
    (MandateRefOptionalFields -> MandateRefOptionalFields)
    -> MandateRef
buildMandateRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { id = optionals.id, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains, policies = optionals.policies }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandateRef input object.
-}
type alias MandateRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", Encode.string |> Encode.optional input.domains ), ( "policies", Encode.string |> Encode.optional input.policies ) ]


buildMultiPolygonRef :
    MultiPolygonRefRequiredFields
    -> MultiPolygonRef
buildMultiPolygonRef required =
    MultiPolygonRef { polygons = required.polygons }


type alias MultiPolygonRefRequiredFields =
    { polygons : List PolygonRef }


{-| Type alias for the `MultiPolygonRef` attributes. Note that this type
needs to use the `MultiPolygonRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MultiPolygonRefRaw =
    { polygons : List PolygonRef }


{-| Type for the MultiPolygonRef input object.
-}
type MultiPolygonRef
    = MultiPolygonRef MultiPolygonRefRaw


{-| Encode a MultiPolygonRef into a value that can be used as an argument.
-}
encodeMultiPolygonRef : MultiPolygonRef -> Value
encodeMultiPolygonRef (MultiPolygonRef input) =
    Encode.maybeObject
        [ ( "polygons", (encodePolygonRef |> Encode.list) input.polygons |> Just ) ]


buildNearFilter :
    NearFilterRequiredFields
    -> NearFilter
buildNearFilter required =
    { distance = required.distance, coordinate = required.coordinate }


type alias NearFilterRequiredFields =
    { distance : Float
    , coordinate : PointRef
    }


{-| Type for the NearFilter input object.
-}
type alias NearFilter =
    { distance : Float
    , coordinate : PointRef
    }


{-| Encode a NearFilter into a value that can be used as an argument.
-}
encodeNearFilter : NearFilter -> Value
encodeNearFilter input =
    Encode.maybeObject
        [ ( "distance", Encode.float input.distance |> Just ), ( "coordinate", encodePointRef input.coordinate |> Just ) ]


buildNodeCharacFilter :
    (NodeCharacFilterOptionalFields -> NodeCharacFilterOptionalFields)
    -> NodeCharacFilter
buildNodeCharacFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeCharacFilter { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeCharacFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeCharacHasFilter.NodeCharacHasFilter))
    , and : OptionalArgument (List (Maybe NodeCharacFilter))
    , or : OptionalArgument (List (Maybe NodeCharacFilter))
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type alias for the `NodeCharacFilter` attributes. Note that this type
needs to use the `NodeCharacFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeCharacFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument NodeMode_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeCharacHasFilter.NodeCharacHasFilter))
    , and : OptionalArgument (List (Maybe NodeCharacFilter))
    , or : OptionalArgument (List (Maybe NodeCharacFilter))
    , not : OptionalArgument NodeCharacFilter
    }


{-| Type for the NodeCharacFilter input object.
-}
type NodeCharacFilter
    = NodeCharacFilter NodeCharacFilterRaw


{-| Encode a NodeCharacFilter into a value that can be used as an argument.
-}
encodeNodeCharacFilter : NodeCharacFilter -> Value
encodeNodeCharacFilter (NodeCharacFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", encodeNodeMode_hash |> Encode.optional input.mode ), ( "has", (Encode.enum Fractal.Enum.NodeCharacHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeNodeCharacFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeNodeCharacFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeNodeCharacFilter |> Encode.optional input.not ) ]


buildNodeCharacPatch :
    (NodeCharacPatchOptionalFields -> NodeCharacPatchOptionalFields)
    -> NodeCharacPatch
buildNodeCharacPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { userCanJoin = Absent, mode = Absent }
    in
    { userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacPatchOptionalFields =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacPatch input object.
-}
type alias NodeCharacPatch =
    { userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacPatch into a value that can be used as an argument.
-}
encodeNodeCharacPatch : NodeCharacPatch -> Value
encodeNodeCharacPatch input =
    Encode.maybeObject
        [ ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeCharacRef :
    (NodeCharacRefOptionalFields -> NodeCharacRefOptionalFields)
    -> NodeCharacRef
buildNodeCharacRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, userCanJoin = Absent, mode = Absent }
    in
    { id = optionals.id, userCanJoin = optionals.userCanJoin, mode = optionals.mode }


type alias NodeCharacRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Type for the NodeCharacRef input object.
-}
type alias NodeCharacRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , userCanJoin : OptionalArgument Bool
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    }


{-| Encode a NodeCharacRef into a value that can be used as an argument.
-}
encodeNodeCharacRef : NodeCharacRef -> Value
encodeNodeCharacRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "userCanJoin", Encode.bool |> Encode.optional input.userCanJoin ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.mode ) ]


buildNodeFilter :
    (NodeFilterOptionalFields -> NodeFilterOptionalFields)
    -> NodeFilter
buildNodeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, type_ = Absent, about = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, skills = Absent, role_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals.id, createdAt = optionals.createdAt, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, type_ = optionals.type_, about = optionals.about, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, skills = optionals.skills, role_type = optionals.role_type, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.nameid ), ( "rootnameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.rootnameid ), ( "type_", encodeNodeType_hash |> Encode.optional input.type_ ), ( "about", encodeStringFullTextFilter |> Encode.optional input.about ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "skills", encodeStringTermFilter |> Encode.optional input.skills ), ( "role_type", encodeRoleType_hash |> Encode.optional input.role_type ), ( "has", (Encode.enum Fractal.Enum.NodeHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeNodeFilter |> Encode.optional input.not ) ]


buildNodeFragmentFilter :
    (NodeFragmentFilterOptionalFields -> NodeFragmentFilterOptionalFields)
    -> NodeFragmentFilter
buildNodeFragmentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFragmentFilter { id = optionals.id, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeFragmentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type alias for the `NodeFragmentFilter` attributes. Note that this type
needs to use the `NodeFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type for the NodeFragmentFilter input object.
-}
type NodeFragmentFilter
    = NodeFragmentFilter NodeFragmentFilterRaw


{-| Encode a NodeFragmentFilter into a value that can be used as an argument.
-}
encodeNodeFragmentFilter : NodeFragmentFilter -> Value
encodeNodeFragmentFilter (NodeFragmentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "has", (Encode.enum Fractal.Enum.NodeFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeNodeFragmentFilter |> Encode.optional input.not ) ]


buildNodeFragmentOrder :
    (NodeFragmentOrderOptionalFields -> NodeFragmentOrderOptionalFields)
    -> NodeFragmentOrder
buildNodeFragmentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeFragmentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type alias for the `NodeFragmentOrder` attributes. Note that this type
needs to use the `NodeFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type for the NodeFragmentOrder input object.
-}
type NodeFragmentOrder
    = NodeFragmentOrder NodeFragmentOrderRaw


{-| Encode a NodeFragmentOrder into a value that can be used as an argument.
-}
encodeNodeFragmentOrder : NodeFragmentOrder -> Value
encodeNodeFragmentOrder (NodeFragmentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeFragmentOrder |> Encode.optional input.then_ ) ]


buildNodeFragmentPatch :
    (NodeFragmentPatchOptionalFields -> NodeFragmentPatchOptionalFields)
    -> NodeFragmentPatch
buildNodeFragmentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodeFragmentPatch { name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodeFragmentPatchOptionalFields =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentPatch` attributes. Note that this type
needs to use the `NodeFragmentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentPatchRaw =
    { name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentPatch input object.
-}
type NodeFragmentPatch
    = NodeFragmentPatch NodeFragmentPatchRaw


{-| Encode a NodeFragmentPatch into a value that can be used as an argument.
-}
encodeNodeFragmentPatch : NodeFragmentPatch -> Value
encodeNodeFragmentPatch (NodeFragmentPatch input) =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeFragmentRef :
    (NodeFragmentRefOptionalFields -> NodeFragmentRefOptionalFields)
    -> NodeFragmentRef
buildNodeFragmentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, nameid = Absent, type_ = Absent, isPrivate = Absent, charac = Absent, about = Absent, mandate = Absent, children = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent }
    in
    NodeFragmentRef { id = optionals.id, name = optionals.name, nameid = optionals.nameid, type_ = optionals.type_, isPrivate = optionals.isPrivate, charac = optionals.charac, about = optionals.about, mandate = optionals.mandate, children = optionals.children, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type }


type alias NodeFragmentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentRef` attributes. Note that this type
needs to use the `NodeFragmentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , isPrivate : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , children : OptionalArgument (List NodeFragmentRef)
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentRef input object.
-}
type NodeFragmentRef
    = NodeFragmentRef NodeFragmentRefRaw


{-| Encode a NodeFragmentRef into a value that can be used as an argument.
-}
encodeNodeFragmentRef : NodeFragmentRef -> Value
encodeNodeFragmentRef (NodeFragmentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input.children ), ( "first_link", Encode.string |> Encode.optional input.first_link ), ( "second_link", Encode.string |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ) ]


buildNodeMode_hash :
    (NodeMode_hashOptionalFields -> NodeMode_hashOptionalFields)
    -> NodeMode_hash
buildNodeMode_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias NodeMode_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Type for the NodeMode\_hash input object.
-}
type alias NodeMode_hash =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Encode a NodeMode\_hash into a value that can be used as an argument.
-}
encodeNodeMode_hash : NodeMode_hash -> Value
encodeNodeMode_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.NodeMode.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildNodeOrder :
    (NodeOrderOptionalFields -> NodeOrderOptionalFields)
    -> NodeOrder
buildNodeOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeOrder |> Encode.optional input.then_ ) ]


buildNodePatch :
    (NodePatchOptionalFields -> NodePatchOptionalFields)
    -> NodePatch
buildNodePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, charac = Absent, rights = Absent, labels = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, contracts = Absent, orga_agg = Absent }
    in
    NodePatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, name = optionals.name, rootnameid = optionals.rootnameid, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, charac = optionals.charac, rights = optionals.rights, labels = optionals.labels, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, contracts = optionals.contracts, orga_agg = optionals.orga_agg }


type alias NodePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , rights : OptionalArgument Int
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , rights : OptionalArgument Int
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string |> Encode.optional input.name ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "rights", Encode.int |> Encode.optional input.rights ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input.orga_agg ) ]


buildNodeRef :
    (NodeRefOptionalFields -> NodeRefOptionalFields)
    -> NodeRef
buildNodeRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, isRoot = Absent, isPersonal = Absent, isPrivate = Absent, isArchived = Absent, charac = Absent, rights = Absent, labels = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, contracts = Absent, orga_agg = Absent }
    in
    NodeRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, name = optionals.name, nameid = optionals.nameid, rootnameid = optionals.rootnameid, parent = optionals.parent, children = optionals.children, type_ = optionals.type_, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, about = optionals.about, mandate = optionals.mandate, docs = optionals.docs, source = optionals.source, isRoot = optionals.isRoot, isPersonal = optionals.isPersonal, isPrivate = optionals.isPrivate, isArchived = optionals.isArchived, charac = optionals.charac, rights = optionals.rights, labels = optionals.labels, first_link = optionals.first_link, second_link = optionals.second_link, skills = optionals.skills, role_type = optionals.role_type, contracts = optionals.contracts, orga_agg = optionals.orga_agg }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , rights : OptionalArgument Int
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `NodeRef` attributes. Note that this type
needs to use the `NodeRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , isPrivate : OptionalArgument Bool
    , isArchived : OptionalArgument Bool
    , charac : OptionalArgument NodeCharacRef
    , rights : OptionalArgument Int
    , labels : OptionalArgument (List LabelRef)
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the NodeRef input object.
-}
type NodeRef
    = NodeRef NodeRefRaw


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef (NodeRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "rootnameid", Encode.string |> Encode.optional input.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "about", Encode.string |> Encode.optional input.about ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input.docs ), ( "source", encodeBlobRef |> Encode.optional input.source ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input.isPersonal ), ( "isPrivate", Encode.bool |> Encode.optional input.isPrivate ), ( "isArchived", Encode.bool |> Encode.optional input.isArchived ), ( "charac", encodeNodeCharacRef |> Encode.optional input.charac ), ( "rights", Encode.int |> Encode.optional input.rights ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "first_link", encodeUserRef |> Encode.optional input.first_link ), ( "second_link", encodeUserRef |> Encode.optional input.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.role_type ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input.orga_agg ) ]


buildNodeType_hash :
    (NodeType_hashOptionalFields -> NodeType_hashOptionalFields)
    -> NodeType_hash
buildNodeType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias NodeType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Type for the NodeType\_hash input object.
-}
type alias NodeType_hash =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Encode a NodeType\_hash into a value that can be used as an argument.
-}
encodeNodeType_hash : NodeType_hash -> Value
encodeNodeType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.NodeType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildOrgaAggFilter :
    (OrgaAggFilterOptionalFields -> OrgaAggFilterOptionalFields)
    -> OrgaAggFilter
buildOrgaAggFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    OrgaAggFilter { has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias OrgaAggFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.OrgaAggHasFilter.OrgaAggHasFilter))
    , and : OptionalArgument (List (Maybe OrgaAggFilter))
    , or : OptionalArgument (List (Maybe OrgaAggFilter))
    , not : OptionalArgument OrgaAggFilter
    }


{-| Type alias for the `OrgaAggFilter` attributes. Note that this type
needs to use the `OrgaAggFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias OrgaAggFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.OrgaAggHasFilter.OrgaAggHasFilter))
    , and : OptionalArgument (List (Maybe OrgaAggFilter))
    , or : OptionalArgument (List (Maybe OrgaAggFilter))
    , not : OptionalArgument OrgaAggFilter
    }


{-| Type for the OrgaAggFilter input object.
-}
type OrgaAggFilter
    = OrgaAggFilter OrgaAggFilterRaw


{-| Encode a OrgaAggFilter into a value that can be used as an argument.
-}
encodeOrgaAggFilter : OrgaAggFilter -> Value
encodeOrgaAggFilter (OrgaAggFilter input) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.OrgaAggHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeOrgaAggFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeOrgaAggFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeOrgaAggFilter |> Encode.optional input.not ) ]


buildOrgaAggOrder :
    (OrgaAggOrderOptionalFields -> OrgaAggOrderOptionalFields)
    -> OrgaAggOrder
buildOrgaAggOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    OrgaAggOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias OrgaAggOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , desc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , then_ : OptionalArgument OrgaAggOrder
    }


{-| Type alias for the `OrgaAggOrder` attributes. Note that this type
needs to use the `OrgaAggOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias OrgaAggOrderRaw =
    { asc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , desc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , then_ : OptionalArgument OrgaAggOrder
    }


{-| Type for the OrgaAggOrder input object.
-}
type OrgaAggOrder
    = OrgaAggOrder OrgaAggOrderRaw


{-| Encode a OrgaAggOrder into a value that can be used as an argument.
-}
encodeOrgaAggOrder : OrgaAggOrder -> Value
encodeOrgaAggOrder (OrgaAggOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.OrgaAggOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.OrgaAggOrderable.toString |> Encode.optional input.desc ), ( "then", encodeOrgaAggOrder |> Encode.optional input.then_ ) ]


buildOrgaAggPatch :
    (OrgaAggPatchOptionalFields -> OrgaAggPatchOptionalFields)
    -> OrgaAggPatch
buildOrgaAggPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals.n_members, n_guests = optionals.n_guests }


type alias OrgaAggPatchOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the OrgaAggPatch input object.
-}
type alias OrgaAggPatch =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a OrgaAggPatch into a value that can be used as an argument.
-}
encodeOrgaAggPatch : OrgaAggPatch -> Value
encodeOrgaAggPatch input =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input.n_members ), ( "n_guests", Encode.int |> Encode.optional input.n_guests ) ]


buildOrgaAggRef :
    (OrgaAggRefOptionalFields -> OrgaAggRefOptionalFields)
    -> OrgaAggRef
buildOrgaAggRef fillOptionals =
    let
        optionals =
            fillOptionals
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals.n_members, n_guests = optionals.n_guests }


type alias OrgaAggRefOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the OrgaAggRef input object.
-}
type alias OrgaAggRef =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a OrgaAggRef into a value that can be used as an argument.
-}
encodeOrgaAggRef : OrgaAggRef -> Value
encodeOrgaAggRef input =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input.n_members ), ( "n_guests", Encode.int |> Encode.optional input.n_guests ) ]


buildPointGeoFilter :
    (PointGeoFilterOptionalFields -> PointGeoFilterOptionalFields)
    -> PointGeoFilter
buildPointGeoFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { near = Absent, within = Absent }
    in
    PointGeoFilter { near = optionals.near, within = optionals.within }


type alias PointGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Type alias for the `PointGeoFilter` attributes. Note that this type
needs to use the `PointGeoFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PointGeoFilterRaw =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Type for the PointGeoFilter input object.
-}
type PointGeoFilter
    = PointGeoFilter PointGeoFilterRaw


{-| Encode a PointGeoFilter into a value that can be used as an argument.
-}
encodePointGeoFilter : PointGeoFilter -> Value
encodePointGeoFilter (PointGeoFilter input) =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input.near ), ( "within", encodeWithinFilter |> Encode.optional input.within ) ]


buildPointListRef :
    PointListRefRequiredFields
    -> PointListRef
buildPointListRef required =
    { points = required.points }


type alias PointListRefRequiredFields =
    { points : List PointRef }


{-| Type for the PointListRef input object.
-}
type alias PointListRef =
    { points : List PointRef }


{-| Encode a PointListRef into a value that can be used as an argument.
-}
encodePointListRef : PointListRef -> Value
encodePointListRef input =
    Encode.maybeObject
        [ ( "points", (encodePointRef |> Encode.list) input.points |> Just ) ]


buildPointRef :
    PointRefRequiredFields
    -> PointRef
buildPointRef required =
    { longitude = required.longitude, latitude = required.latitude }


type alias PointRefRequiredFields =
    { longitude : Float
    , latitude : Float
    }


{-| Type for the PointRef input object.
-}
type alias PointRef =
    { longitude : Float
    , latitude : Float
    }


{-| Encode a PointRef into a value that can be used as an argument.
-}
encodePointRef : PointRef -> Value
encodePointRef input =
    Encode.maybeObject
        [ ( "longitude", Encode.float input.longitude |> Just ), ( "latitude", Encode.float input.latitude |> Just ) ]


buildPolygonGeoFilter :
    (PolygonGeoFilterOptionalFields -> PolygonGeoFilterOptionalFields)
    -> PolygonGeoFilter
buildPolygonGeoFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { near = Absent, within = Absent, contains = Absent, intersects = Absent }
    in
    PolygonGeoFilter { near = optionals.near, within = optionals.within, contains = optionals.contains, intersects = optionals.intersects }


type alias PolygonGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Type alias for the `PolygonGeoFilter` attributes. Note that this type
needs to use the `PolygonGeoFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PolygonGeoFilterRaw =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Type for the PolygonGeoFilter input object.
-}
type PolygonGeoFilter
    = PolygonGeoFilter PolygonGeoFilterRaw


{-| Encode a PolygonGeoFilter into a value that can be used as an argument.
-}
encodePolygonGeoFilter : PolygonGeoFilter -> Value
encodePolygonGeoFilter (PolygonGeoFilter input) =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input.near ), ( "within", encodeWithinFilter |> Encode.optional input.within ), ( "contains", encodeContainsFilter |> Encode.optional input.contains ), ( "intersects", encodeIntersectsFilter |> Encode.optional input.intersects ) ]


buildPolygonRef :
    PolygonRefRequiredFields
    -> PolygonRef
buildPolygonRef required =
    { coordinates = required.coordinates }


type alias PolygonRefRequiredFields =
    { coordinates : List PointListRef }


{-| Type for the PolygonRef input object.
-}
type alias PolygonRef =
    { coordinates : List PointListRef }


{-| Encode a PolygonRef into a value that can be used as an argument.
-}
encodePolygonRef : PolygonRef -> Value
encodePolygonRef input =
    Encode.maybeObject
        [ ( "coordinates", (encodePointListRef |> Encode.list) input.coordinates |> Just ) ]


buildPostFilter :
    (PostFilterOptionalFields -> PostFilterOptionalFields)
    -> PostFilter
buildPostFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "has", (Encode.enum Fractal.Enum.PostHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodePostFilter |> Encode.optional input.not ) ]


buildPostOrder :
    (PostOrderOptionalFields -> PostOrderOptionalFields)
    -> PostOrder
buildPostOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.desc ), ( "then", encodePostOrder |> Encode.optional input.then_ ) ]


buildPostPatch :
    (PostPatchOptionalFields -> PostPatchOptionalFields)
    -> PostPatch
buildPostPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent }
    in
    PostPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message }


type alias PostPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ) ]


buildPostRef :
    PostRefRequiredFields
    -> PostRef
buildPostRef required =
    { id = required.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input.id |> Just ) ]


buildRoleType_hash :
    (RoleType_hashOptionalFields -> RoleType_hashOptionalFields)
    -> RoleType_hash
buildRoleType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias RoleType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Type for the RoleType\_hash input object.
-}
type alias RoleType_hash =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Encode a RoleType\_hash into a value that can be used as an argument.
-}
encodeRoleType_hash : RoleType_hash -> Value
encodeRoleType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.RoleType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildStringExactFilter :
    (StringExactFilterOptionalFields -> StringExactFilterOptionalFields)
    -> StringExactFilter
buildStringExactFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt, between = optionals.between }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "le", Encode.string |> Encode.optional input.le ), ( "lt", Encode.string |> Encode.optional input.lt ), ( "ge", Encode.string |> Encode.optional input.ge ), ( "gt", Encode.string |> Encode.optional input.gt ), ( "between", encodeStringRange |> Encode.optional input.between ) ]


buildStringFullTextFilter :
    (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields)
    -> StringFullTextFilter
buildStringFullTextFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals.alloftext, anyoftext = optionals.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input.anyoftext ) ]


buildStringHashFilter :
    (StringHashFilterOptionalFields -> StringHashFilterOptionalFields)
    -> StringHashFilter
buildStringHashFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildStringHashFilter_StringRegExpFilter :
    (StringHashFilter_StringRegExpFilterOptionalFields -> StringHashFilter_StringRegExpFilterOptionalFields)
    -> StringHashFilter_StringRegExpFilter
buildStringHashFilter_StringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, regexp = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, regexp = optionals.regexp }


type alias StringHashFilter_StringRegExpFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringRegExpFilter input object.
-}
type alias StringHashFilter_StringRegExpFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringRegExpFilter : StringHashFilter_StringRegExpFilter -> Value
encodeStringHashFilter_StringRegExpFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringHashFilter_StringTermFilter :
    (StringHashFilter_StringTermFilterOptionalFields -> StringHashFilter_StringTermFilterOptionalFields)
    -> StringHashFilter_StringTermFilter
buildStringHashFilter_StringTermFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent, allofterms = Absent, anyofterms = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_, allofterms = optionals.allofterms, anyofterms = optionals.anyofterms }


type alias StringHashFilter_StringTermFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringTermFilter input object.
-}
type alias StringHashFilter_StringTermFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringTermFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringTermFilter : StringHashFilter_StringTermFilter -> Value
encodeStringHashFilter_StringTermFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "allofterms", Encode.string |> Encode.optional input.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input.anyofterms ) ]


buildStringRange :
    StringRangeRequiredFields
    -> StringRange
buildStringRange required =
    { min = required.min, max = required.max }


type alias StringRangeRequiredFields =
    { min : String
    , max : String
    }


{-| Type for the StringRange input object.
-}
type alias StringRange =
    { min : String
    , max : String
    }


{-| Encode a StringRange into a value that can be used as an argument.
-}
encodeStringRange : StringRange -> Value
encodeStringRange input =
    Encode.maybeObject
        [ ( "min", Encode.string input.min |> Just ), ( "max", Encode.string input.max |> Just ) ]


buildStringRegExpFilter :
    (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields)
    -> StringRegExpFilter
buildStringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { regexp = Absent }
    in
    { regexp = optionals.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringTermFilter :
    (StringTermFilterOptionalFields -> StringTermFilterOptionalFields)
    -> StringTermFilter
buildStringTermFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals.allofterms, anyofterms = optionals.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input.anyofterms ) ]


buildTensionEvent_hash :
    (TensionEvent_hashOptionalFields -> TensionEvent_hashOptionalFields)
    -> TensionEvent_hash
buildTensionEvent_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias TensionEvent_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Type for the TensionEvent\_hash input object.
-}
type alias TensionEvent_hash =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Encode a TensionEvent\_hash into a value that can be used as an argument.
-}
encodeTensionEvent_hash : TensionEvent_hash -> Value
encodeTensionEvent_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildTensionFilter :
    (TensionFilterOptionalFields -> TensionFilterOptionalFields)
    -> TensionFilter
buildTensionFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, emitterid = Absent, receiverid = Absent, nth = Absent, title = Absent, type_ = Absent, status = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, emitterid = optionals.emitterid, receiverid = optionals.receiverid, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, status = optionals.status, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , nth : OptionalArgument StringTermFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "emitterid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.emitterid ), ( "receiverid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input.receiverid ), ( "nth", encodeStringTermFilter |> Encode.optional input.nth ), ( "title", encodeStringFullTextFilter |> Encode.optional input.title ), ( "type_", encodeTensionType_hash |> Encode.optional input.type_ ), ( "status", encodeTensionStatus_hash |> Encode.optional input.status ), ( "has", (Encode.enum Fractal.Enum.TensionHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeTensionFilter |> Encode.optional input.not ) ]


buildTensionOrder :
    (TensionOrderOptionalFields -> TensionOrderOptionalFields)
    -> TensionOrder
buildTensionOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.desc ), ( "then", encodeTensionOrder |> Encode.optional input.then_ ) ]


buildTensionPatch :
    (TensionPatchOptionalFields -> TensionPatchOptionalFields)
    -> TensionPatch
buildTensionPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitterid = Absent, emitter = Absent, receiverid = Absent, receiver = Absent, nth = Absent, title = Absent, type_ = Absent, status = Absent, assignees = Absent, labels = Absent, comments = Absent, action = Absent, blobs = Absent, contracts = Absent, history = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    TensionPatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, emitterid = optionals.emitterid, emitter = optionals.emitter, receiverid = optionals.receiverid, receiver = optionals.receiver, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, status = optionals.status, assignees = optionals.assignees, labels = optionals.labels, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, contracts = optionals.contracts, history = optionals.history, n_comments = optionals.n_comments, n_open_contracts = optionals.n_open_contracts }


type alias TensionPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input.history ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input.n_open_contracts ) ]


buildTensionRef :
    (TensionRefOptionalFields -> TensionRefOptionalFields)
    -> TensionRef
buildTensionRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitterid = Absent, emitter = Absent, receiverid = Absent, receiver = Absent, nth = Absent, title = Absent, type_ = Absent, status = Absent, assignees = Absent, labels = Absent, comments = Absent, action = Absent, blobs = Absent, contracts = Absent, history = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    TensionRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, emitterid = optionals.emitterid, emitter = optionals.emitter, receiverid = optionals.receiverid, receiver = optionals.receiver, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, status = optionals.status, assignees = optionals.assignees, labels = optionals.labels, comments = optionals.comments, action = optionals.action, blobs = optionals.blobs, contracts = optionals.contracts, history = optionals.history, n_comments = optionals.n_comments, n_open_contracts = optionals.n_open_contracts }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitterid : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , nth : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , history : OptionalArgument (List EventRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "emitterid", Encode.string |> Encode.optional input.emitterid ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receiverid", Encode.string |> Encode.optional input.receiverid ), ( "receiver", encodeNodeRef |> Encode.optional input.receiver ), ( "nth", Encode.string |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.status ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input.action ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input.blobs ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input.history ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input.n_open_contracts ) ]


buildTensionStatus_hash :
    (TensionStatus_hashOptionalFields -> TensionStatus_hashOptionalFields)
    -> TensionStatus_hash
buildTensionStatus_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias TensionStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Type for the TensionStatus\_hash input object.
-}
type alias TensionStatus_hash =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Encode a TensionStatus\_hash into a value that can be used as an argument.
-}
encodeTensionStatus_hash : TensionStatus_hash -> Value
encodeTensionStatus_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildTensionType_hash :
    (TensionType_hashOptionalFields -> TensionType_hashOptionalFields)
    -> TensionType_hash
buildTensionType_hash fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals.eq, in_ = optionals.in_ }


type alias TensionType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.eq ), ( "in", (Encode.enum Fractal.Enum.TensionType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ) ]


buildUpdateBlobInput :
    UpdateBlobInputRequiredFields
    -> (UpdateBlobInputOptionalFields -> UpdateBlobInputOptionalFields)
    -> UpdateBlobInput
buildUpdateBlobInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateBlobInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateBlobInputRequiredFields =
    { filter : BlobFilter }


type alias UpdateBlobInputOptionalFields =
    { set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type alias for the `UpdateBlobInput` attributes. Note that this type
needs to use the `UpdateBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateBlobInputRaw =
    { filter : BlobFilter
    , set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type for the UpdateBlobInput input object.
-}
type UpdateBlobInput
    = UpdateBlobInput UpdateBlobInputRaw


{-| Encode a UpdateBlobInput into a value that can be used as an argument.
-}
encodeUpdateBlobInput : UpdateBlobInput -> Value
encodeUpdateBlobInput (UpdateBlobInput input) =
    Encode.maybeObject
        [ ( "filter", encodeBlobFilter input.filter |> Just ), ( "set", encodeBlobPatch |> Encode.optional input.set ), ( "remove", encodeBlobPatch |> Encode.optional input.remove ) ]


buildUpdateCommentInput :
    UpdateCommentInputRequiredFields
    -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields)
    -> UpdateCommentInput
buildUpdateCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input.set ), ( "remove", encodeCommentPatch |> Encode.optional input.remove ) ]


buildUpdateContractInput :
    UpdateContractInputRequiredFields
    -> (UpdateContractInputOptionalFields -> UpdateContractInputOptionalFields)
    -> UpdateContractInput
buildUpdateContractInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateContractInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateContractInputRequiredFields =
    { filter : ContractFilter }


type alias UpdateContractInputOptionalFields =
    { set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type alias for the `UpdateContractInput` attributes. Note that this type
needs to use the `UpdateContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateContractInputRaw =
    { filter : ContractFilter
    , set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type for the UpdateContractInput input object.
-}
type UpdateContractInput
    = UpdateContractInput UpdateContractInputRaw


{-| Encode a UpdateContractInput into a value that can be used as an argument.
-}
encodeUpdateContractInput : UpdateContractInput -> Value
encodeUpdateContractInput (UpdateContractInput input) =
    Encode.maybeObject
        [ ( "filter", encodeContractFilter input.filter |> Just ), ( "set", encodeContractPatch |> Encode.optional input.set ), ( "remove", encodeContractPatch |> Encode.optional input.remove ) ]


buildUpdateEventFragmentInput :
    UpdateEventFragmentInputRequiredFields
    -> (UpdateEventFragmentInputOptionalFields -> UpdateEventFragmentInputOptionalFields)
    -> UpdateEventFragmentInput
buildUpdateEventFragmentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateEventFragmentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateEventFragmentInputRequiredFields =
    { filter : EventFragmentFilter }


type alias UpdateEventFragmentInputOptionalFields =
    { set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type alias for the `UpdateEventFragmentInput` attributes. Note that this type
needs to use the `UpdateEventFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventFragmentInputRaw =
    { filter : EventFragmentFilter
    , set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type for the UpdateEventFragmentInput input object.
-}
type UpdateEventFragmentInput
    = UpdateEventFragmentInput UpdateEventFragmentInputRaw


{-| Encode a UpdateEventFragmentInput into a value that can be used as an argument.
-}
encodeUpdateEventFragmentInput : UpdateEventFragmentInput -> Value
encodeUpdateEventFragmentInput (UpdateEventFragmentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeEventFragmentFilter input.filter |> Just ), ( "set", encodeEventFragmentPatch |> Encode.optional input.set ), ( "remove", encodeEventFragmentPatch |> Encode.optional input.remove ) ]


buildUpdateEventInput :
    UpdateEventInputRequiredFields
    -> (UpdateEventInputOptionalFields -> UpdateEventInputOptionalFields)
    -> UpdateEventInput
buildUpdateEventInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateEventInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateEventInputRequiredFields =
    { filter : EventFilter }


type alias UpdateEventInputOptionalFields =
    { set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type alias for the `UpdateEventInput` attributes. Note that this type
needs to use the `UpdateEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventInputRaw =
    { filter : EventFilter
    , set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type for the UpdateEventInput input object.
-}
type UpdateEventInput
    = UpdateEventInput UpdateEventInputRaw


{-| Encode a UpdateEventInput into a value that can be used as an argument.
-}
encodeUpdateEventInput : UpdateEventInput -> Value
encodeUpdateEventInput (UpdateEventInput input) =
    Encode.maybeObject
        [ ( "filter", encodeEventFilter input.filter |> Just ), ( "set", encodeEventPatch |> Encode.optional input.set ), ( "remove", encodeEventPatch |> Encode.optional input.remove ) ]


buildUpdateLabelInput :
    UpdateLabelInputRequiredFields
    -> (UpdateLabelInputOptionalFields -> UpdateLabelInputOptionalFields)
    -> UpdateLabelInput
buildUpdateLabelInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateLabelInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateLabelInputRequiredFields =
    { filter : LabelFilter }


type alias UpdateLabelInputOptionalFields =
    { set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type alias for the `UpdateLabelInput` attributes. Note that this type
needs to use the `UpdateLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateLabelInputRaw =
    { filter : LabelFilter
    , set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type for the UpdateLabelInput input object.
-}
type UpdateLabelInput
    = UpdateLabelInput UpdateLabelInputRaw


{-| Encode a UpdateLabelInput into a value that can be used as an argument.
-}
encodeUpdateLabelInput : UpdateLabelInput -> Value
encodeUpdateLabelInput (UpdateLabelInput input) =
    Encode.maybeObject
        [ ( "filter", encodeLabelFilter input.filter |> Just ), ( "set", encodeLabelPatch |> Encode.optional input.set ), ( "remove", encodeLabelPatch |> Encode.optional input.remove ) ]


buildUpdateMandateInput :
    UpdateMandateInputRequiredFields
    -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields)
    -> UpdateMandateInput
buildUpdateMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input.set ), ( "remove", encodeMandatePatch |> Encode.optional input.remove ) ]


buildUpdateNodeCharacInput :
    UpdateNodeCharacInputRequiredFields
    -> (UpdateNodeCharacInputOptionalFields -> UpdateNodeCharacInputOptionalFields)
    -> UpdateNodeCharacInput
buildUpdateNodeCharacInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeCharacInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeCharacInputRequiredFields =
    { filter : NodeCharacFilter }


type alias UpdateNodeCharacInputOptionalFields =
    { set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type alias for the `UpdateNodeCharacInput` attributes. Note that this type
needs to use the `UpdateNodeCharacInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeCharacInputRaw =
    { filter : NodeCharacFilter
    , set : OptionalArgument NodeCharacPatch
    , remove : OptionalArgument NodeCharacPatch
    }


{-| Type for the UpdateNodeCharacInput input object.
-}
type UpdateNodeCharacInput
    = UpdateNodeCharacInput UpdateNodeCharacInputRaw


{-| Encode a UpdateNodeCharacInput into a value that can be used as an argument.
-}
encodeUpdateNodeCharacInput : UpdateNodeCharacInput -> Value
encodeUpdateNodeCharacInput (UpdateNodeCharacInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeCharacFilter input.filter |> Just ), ( "set", encodeNodeCharacPatch |> Encode.optional input.set ), ( "remove", encodeNodeCharacPatch |> Encode.optional input.remove ) ]


buildUpdateNodeFragmentInput :
    UpdateNodeFragmentInputRequiredFields
    -> (UpdateNodeFragmentInputOptionalFields -> UpdateNodeFragmentInputOptionalFields)
    -> UpdateNodeFragmentInput
buildUpdateNodeFragmentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeFragmentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeFragmentInputRequiredFields =
    { filter : NodeFragmentFilter }


type alias UpdateNodeFragmentInputOptionalFields =
    { set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type alias for the `UpdateNodeFragmentInput` attributes. Note that this type
needs to use the `UpdateNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeFragmentInputRaw =
    { filter : NodeFragmentFilter
    , set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type for the UpdateNodeFragmentInput input object.
-}
type UpdateNodeFragmentInput
    = UpdateNodeFragmentInput UpdateNodeFragmentInputRaw


{-| Encode a UpdateNodeFragmentInput into a value that can be used as an argument.
-}
encodeUpdateNodeFragmentInput : UpdateNodeFragmentInput -> Value
encodeUpdateNodeFragmentInput (UpdateNodeFragmentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFragmentFilter input.filter |> Just ), ( "set", encodeNodeFragmentPatch |> Encode.optional input.set ), ( "remove", encodeNodeFragmentPatch |> Encode.optional input.remove ) ]


buildUpdateNodeInput :
    UpdateNodeInputRequiredFields
    -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields)
    -> UpdateNodeInput
buildUpdateNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input.set ), ( "remove", encodeNodePatch |> Encode.optional input.remove ) ]


buildUpdateOrgaAggInput :
    UpdateOrgaAggInputRequiredFields
    -> (UpdateOrgaAggInputOptionalFields -> UpdateOrgaAggInputOptionalFields)
    -> UpdateOrgaAggInput
buildUpdateOrgaAggInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateOrgaAggInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateOrgaAggInputRequiredFields =
    { filter : OrgaAggFilter }


type alias UpdateOrgaAggInputOptionalFields =
    { set : OptionalArgument OrgaAggPatch
    , remove : OptionalArgument OrgaAggPatch
    }


{-| Type alias for the `UpdateOrgaAggInput` attributes. Note that this type
needs to use the `UpdateOrgaAggInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateOrgaAggInputRaw =
    { filter : OrgaAggFilter
    , set : OptionalArgument OrgaAggPatch
    , remove : OptionalArgument OrgaAggPatch
    }


{-| Type for the UpdateOrgaAggInput input object.
-}
type UpdateOrgaAggInput
    = UpdateOrgaAggInput UpdateOrgaAggInputRaw


{-| Encode a UpdateOrgaAggInput into a value that can be used as an argument.
-}
encodeUpdateOrgaAggInput : UpdateOrgaAggInput -> Value
encodeUpdateOrgaAggInput (UpdateOrgaAggInput input) =
    Encode.maybeObject
        [ ( "filter", encodeOrgaAggFilter input.filter |> Just ), ( "set", encodeOrgaAggPatch |> Encode.optional input.set ), ( "remove", encodeOrgaAggPatch |> Encode.optional input.remove ) ]


buildUpdatePostInput :
    UpdatePostInputRequiredFields
    -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields)
    -> UpdatePostInput
buildUpdatePostInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input.set ), ( "remove", encodePostPatch |> Encode.optional input.remove ) ]


buildUpdateTensionInput :
    UpdateTensionInputRequiredFields
    -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields)
    -> UpdateTensionInput
buildUpdateTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input.set ), ( "remove", encodeTensionPatch |> Encode.optional input.remove ) ]


buildUpdateUserInput :
    UpdateUserInputRequiredFields
    -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields)
    -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input.set ), ( "remove", encodeUserPatch |> Encode.optional input.remove ) ]


buildUpdateUserRightsInput :
    UpdateUserRightsInputRequiredFields
    -> (UpdateUserRightsInputOptionalFields -> UpdateUserRightsInputOptionalFields)
    -> UpdateUserRightsInput
buildUpdateUserRightsInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateUserRightsInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateUserRightsInputRequiredFields =
    { filter : UserRightsFilter }


type alias UpdateUserRightsInputOptionalFields =
    { set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type alias for the `UpdateUserRightsInput` attributes. Note that this type
needs to use the `UpdateUserRightsInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserRightsInputRaw =
    { filter : UserRightsFilter
    , set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type for the UpdateUserRightsInput input object.
-}
type UpdateUserRightsInput
    = UpdateUserRightsInput UpdateUserRightsInputRaw


{-| Encode a UpdateUserRightsInput into a value that can be used as an argument.
-}
encodeUpdateUserRightsInput : UpdateUserRightsInput -> Value
encodeUpdateUserRightsInput (UpdateUserRightsInput input) =
    Encode.maybeObject
        [ ( "filter", encodeUserRightsFilter input.filter |> Just ), ( "set", encodeUserRightsPatch |> Encode.optional input.set ), ( "remove", encodeUserRightsPatch |> Encode.optional input.remove ) ]


buildUpdateVoteInput :
    UpdateVoteInputRequiredFields
    -> (UpdateVoteInputOptionalFields -> UpdateVoteInputOptionalFields)
    -> UpdateVoteInput
buildUpdateVoteInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateVoteInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateVoteInputRequiredFields =
    { filter : VoteFilter }


type alias UpdateVoteInputOptionalFields =
    { set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type alias for the `UpdateVoteInput` attributes. Note that this type
needs to use the `UpdateVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateVoteInputRaw =
    { filter : VoteFilter
    , set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type for the UpdateVoteInput input object.
-}
type UpdateVoteInput
    = UpdateVoteInput UpdateVoteInputRaw


{-| Encode a UpdateVoteInput into a value that can be used as an argument.
-}
encodeUpdateVoteInput : UpdateVoteInput -> Value
encodeUpdateVoteInput (UpdateVoteInput input) =
    Encode.maybeObject
        [ ( "filter", encodeVoteFilter input.filter |> Just ), ( "set", encodeVotePatch |> Encode.optional input.set ), ( "remove", encodeVotePatch |> Encode.optional input.remove ) ]


buildUserFilter :
    (UserFilterOptionalFields -> UserFilterOptionalFields)
    -> UserFilter
buildUserFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, username = Absent, email = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals.id, username = optionals.username, email = optionals.email, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "username", encodeStringHashFilter |> Encode.optional input.username ), ( "email", encodeStringHashFilter |> Encode.optional input.email ), ( "has", (Encode.enum Fractal.Enum.UserHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeUserFilter |> Encode.optional input.not ) ]


buildUserOrder :
    (UserOrderOptionalFields -> UserOrderOptionalFields)
    -> UserOrder
buildUserOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserOrder |> Encode.optional input.then_ ) ]


buildUserPatch :
    (UserPatchOptionalFields -> UserPatchOptionalFields)
    -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, lastAck = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, bio = Absent, utc = Absent }
    in
    UserPatch { createdAt = optionals.createdAt, lastAck = optionals.lastAck, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, contracts = optionals.contracts, bio = optionals.bio, utc = optionals.utc }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lastAck ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRef :
    (UserRefOptionalFields -> UserRefOptionalFields)
    -> UserRef
buildUserRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, lastAck = Absent, username = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, bio = Absent, utc = Absent }
    in
    UserRef { id = optionals.id, createdAt = optionals.createdAt, lastAck = optionals.lastAck, username = optionals.username, name = optionals.name, password = optionals.password, email = optionals.email, emailHash = optionals.emailHash, emailValidated = optionals.emailValidated, rights = optionals.rights, roles = optionals.roles, backed_roles = optionals.backed_roles, tensions_created = optionals.tensions_created, tensions_assigned = optionals.tensions_assigned, contracts = optionals.contracts, bio = optionals.bio, utc = optionals.utc }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lastAck ), ( "username", Encode.string |> Encode.optional input.username ), ( "name", Encode.string |> Encode.optional input.name ), ( "password", Encode.string |> Encode.optional input.password ), ( "email", Encode.string |> Encode.optional input.email ), ( "emailHash", Encode.string |> Encode.optional input.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input.emailValidated ), ( "rights", encodeUserRightsRef |> Encode.optional input.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input.contracts ), ( "bio", Encode.string |> Encode.optional input.bio ), ( "utc", Encode.string |> Encode.optional input.utc ) ]


buildUserRightsFilter :
    (UserRightsFilterOptionalFields -> UserRightsFilterOptionalFields)
    -> UserRightsFilter
buildUserRightsFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserRightsFilter { has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias UserRightsFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type alias for the `UserRightsFilter` attributes. Note that this type
needs to use the `UserRightsFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type for the UserRightsFilter input object.
-}
type UserRightsFilter
    = UserRightsFilter UserRightsFilterRaw


{-| Encode a UserRightsFilter into a value that can be used as an argument.
-}
encodeUserRightsFilter : UserRightsFilter -> Value
encodeUserRightsFilter (UserRightsFilter input) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.UserRightsHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeUserRightsFilter |> Encode.optional input.not ) ]


buildUserRightsOrder :
    (UserRightsOrderOptionalFields -> UserRightsOrderOptionalFields)
    -> UserRightsOrder
buildUserRightsOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserRightsOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserRightsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type alias for the `UserRightsOrder` attributes. Note that this type
needs to use the `UserRightsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type for the UserRightsOrder input object.
-}
type UserRightsOrder
    = UserRightsOrder UserRightsOrderRaw


{-| Encode a UserRightsOrder into a value that can be used as an argument.
-}
encodeUserRightsOrder : UserRightsOrder -> Value
encodeUserRightsOrder (UserRightsOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserRightsOrder |> Encode.optional input.then_ ) ]


buildUserRightsPatch :
    (UserRightsPatchOptionalFields -> UserRightsPatchOptionalFields)
    -> UserRightsPatch
buildUserRightsPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, type_ = Absent }
    in
    { canLogin = optionals.canLogin, canCreateRoot = optionals.canCreateRoot, maxPublicOrga = optionals.maxPublicOrga, type_ = optionals.type_ }


type alias UserRightsPatchOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Type for the UserRightsPatch input object.
-}
type alias UserRightsPatch =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Encode a UserRightsPatch into a value that can be used as an argument.
-}
encodeUserRightsPatch : UserRightsPatch -> Value
encodeUserRightsPatch input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input.maxPublicOrga ), ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input.type_ ) ]


buildUserRightsRef :
    (UserRightsRefOptionalFields -> UserRightsRefOptionalFields)
    -> UserRightsRef
buildUserRightsRef fillOptionals =
    let
        optionals =
            fillOptionals
                { canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, type_ = Absent }
    in
    { canLogin = optionals.canLogin, canCreateRoot = optionals.canCreateRoot, maxPublicOrga = optionals.maxPublicOrga, type_ = optionals.type_ }


type alias UserRightsRefOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Type for the UserRightsRef input object.
-}
type alias UserRightsRef =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Encode a UserRightsRef into a value that can be used as an argument.
-}
encodeUserRightsRef : UserRightsRef -> Value
encodeUserRightsRef input =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input.maxPublicOrga ), ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input.type_ ) ]


buildVoteFilter :
    (VoteFilterOptionalFields -> VoteFilterOptionalFields)
    -> VoteFilter
buildVoteFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, voteId = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    VoteFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, voteId = optionals.voteId, has = optionals.has, and = optionals.and, or = optionals.or, not = optionals.not }


type alias VoteFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteId : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type alias for the `VoteFilter` attributes. Note that this type
needs to use the `VoteFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteId : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type for the VoteFilter input object.
-}
type VoteFilter
    = VoteFilter VoteFilterRaw


{-| Encode a VoteFilter into a value that can be used as an argument.
-}
encodeVoteFilter : VoteFilter -> Value
encodeVoteFilter (VoteFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "voteId", encodeStringHashFilter |> Encode.optional input.voteId ), ( "has", (Encode.enum Fractal.Enum.VoteHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input.has ), ( "and", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.and ), ( "or", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input.or ), ( "not", encodeVoteFilter |> Encode.optional input.not ) ]


buildVoteOrder :
    (VoteOrderOptionalFields -> VoteOrderOptionalFields)
    -> VoteOrder
buildVoteOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    VoteOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias VoteOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type alias for the `VoteOrder` attributes. Note that this type
needs to use the `VoteOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteOrderRaw =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type for the VoteOrder input object.
-}
type VoteOrder
    = VoteOrder VoteOrderRaw


{-| Encode a VoteOrder into a value that can be used as an argument.
-}
encodeVoteOrder : VoteOrder -> Value
encodeVoteOrder (VoteOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input.desc ), ( "then", encodeVoteOrder |> Encode.optional input.then_ ) ]


buildVotePatch :
    (VotePatchOptionalFields -> VotePatchOptionalFields)
    -> VotePatch
buildVotePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VotePatch { createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, contract = optionals.contract, node = optionals.node, data = optionals.data }


type alias VotePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VotePatch` attributes. Note that this type
needs to use the `VotePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VotePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VotePatch input object.
-}
type VotePatch
    = VotePatch VotePatchRaw


{-| Encode a VotePatch into a value that can be used as an argument.
-}
encodeVotePatch : VotePatch -> Value
encodeVotePatch (VotePatch input) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "contract", encodeContractRef |> Encode.optional input.contract ), ( "node", encodeNodeRef |> Encode.optional input.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input.data ) ]


buildVoteRef :
    (VoteRefOptionalFields -> VoteRefOptionalFields)
    -> VoteRef
buildVoteRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, voteId = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VoteRef { id = optionals.id, createdBy = optionals.createdBy, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt, message = optionals.message, voteId = optionals.voteId, contract = optionals.contract, node = optionals.node, data = optionals.data }


type alias VoteRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteId : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VoteRef` attributes. Note that this type
needs to use the `VoteRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteId : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VoteRef input object.
-}
type VoteRef
    = VoteRef VoteRefRaw


{-| Encode a VoteRef into a value that can be used as an argument.
-}
encodeVoteRef : VoteRef -> Value
encodeVoteRef (VoteRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.updatedAt ), ( "message", Encode.string |> Encode.optional input.message ), ( "voteId", Encode.string |> Encode.optional input.voteId ), ( "contract", encodeContractRef |> Encode.optional input.contract ), ( "node", encodeNodeRef |> Encode.optional input.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input.data ) ]


buildWithinFilter :
    WithinFilterRequiredFields
    -> WithinFilter
buildWithinFilter required =
    WithinFilter { polygon = required.polygon }


type alias WithinFilterRequiredFields =
    { polygon : PolygonRef }


{-| Type alias for the `WithinFilter` attributes. Note that this type
needs to use the `WithinFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias WithinFilterRaw =
    { polygon : PolygonRef }


{-| Type for the WithinFilter input object.
-}
type WithinFilter
    = WithinFilter WithinFilterRaw


{-| Encode a WithinFilter into a value that can be used as an argument.
-}
encodeWithinFilter : WithinFilter -> Value
encodeWithinFilter (WithinFilter input) =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef input.polygon |> Just ) ]
