-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.CircleOrderable
import Fractal.Enum.CommentOrderable
import Fractal.Enum.LabelOrderable
import Fractal.Enum.MandateOrderable
import Fractal.Enum.NodeOrderable
import Fractal.Enum.PostOrderable
import Fractal.Enum.RoleOrderable
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionType
import Fractal.Enum.UserOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddCircleInput : AddCircleInputRequiredFields -> (AddCircleInputOptionalFields -> AddCircleInputOptionalFields) -> AddCircleInput
buildAddCircleInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { parent = Absent, children = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent }
    in
    AddCircleInput { createdAt = required.createdAt, createdBy = required.createdBy, parent = optionals.parent, children = optionals.children, name = required.name, nameid = required.nameid, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, isRoot = required.isRoot }


type alias AddCircleInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , name : String
    , nameid : String
    , isRoot : Bool
    }


type alias AddCircleInputOptionalFields =
    { parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    }


{-| Type alias for the `AddCircleInput` attributes. Note that this type
needs to use the `AddCircleInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCircleInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : String
    , nameid : String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , isRoot : Bool
    }


{-| Type for the AddCircleInput input object.
-}
type AddCircleInput
    = AddCircleInput AddCircleInputRaw


{-| Encode a AddCircleInput into a value that can be used as an argument.
-}
encodeAddCircleInput : AddCircleInput -> Value
encodeAddCircleInput (AddCircleInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string input.name |> Just ), ( "nameid", Encode.string input.nameid |> Just ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "isRoot", Encode.bool input.isRoot |> Just ) ]


buildAddCommentInput : AddCommentInputRequiredFields -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields) -> AddCommentInput
buildAddCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { message = Absent, void_ = Absent }
    in
    AddCommentInput { createdAt = required.createdAt, createdBy = required.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias AddCommentInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    }


type alias AddCommentInputOptionalFields =
    { message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildAddLabelInput : AddLabelInputRequiredFields -> AddLabelInput
buildAddLabelInput required =
    { name = required.name }


type alias AddLabelInputRequiredFields =
    { name : String }


{-| Type for the AddLabelInput input object.
-}
type alias AddLabelInput =
    { name : String }


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ) ]


buildAddMandateInput : AddMandateInputRequiredFields -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields) -> AddMandateInput
buildAddMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { message = Absent, responsabilities = Absent, domains = Absent }
    in
    AddMandateInput { createdAt = required.createdAt, createdBy = required.createdBy, message = optionals.message, purpose = required.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains }


type alias AddMandateInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , purpose : String
    }


type alias AddMandateInputOptionalFields =
    { message : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type alias for the `AddMandateInput` attributes. Note that this type
needs to use the `AddMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddMandateInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , message : OptionalArgument String
    , purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type for the AddMandateInput input object.
-}
type AddMandateInput
    = AddMandateInput AddMandateInputRaw


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput (AddMandateInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "message", Encode.string |> Encode.optional input.message ), ( "purpose", Encode.string input.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", (Encode.string |> Encode.list) |> Encode.optional input.domains ) ]


buildAddRoleInput : AddRoleInputRequiredFields -> (AddRoleInputOptionalFields -> AddRoleInputOptionalFields) -> AddRoleInput
buildAddRoleInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { parent = Absent, children = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent, user = Absent, second = Absent, skills = Absent }
    in
    AddRoleInput { createdAt = required.createdAt, createdBy = required.createdBy, parent = optionals.parent, children = optionals.children, name = required.name, nameid = required.nameid, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, user = optionals.user, second = optionals.second, skills = optionals.skills }


type alias AddRoleInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , name : String
    , nameid : String
    }


type alias AddRoleInputOptionalFields =
    { parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type alias for the `AddRoleInput` attributes. Note that this type
needs to use the `AddRoleInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddRoleInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : String
    , nameid : String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type for the AddRoleInput input object.
-}
type AddRoleInput
    = AddRoleInput AddRoleInputRaw


{-| Encode a AddRoleInput into a value that can be used as an argument.
-}
encodeAddRoleInput : AddRoleInput -> Value
encodeAddRoleInput (AddRoleInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string input.name |> Just ), ( "nameid", Encode.string input.nameid |> Just ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "user", encodeUserRef |> Encode.optional input.user ), ( "second", encodeUserRef |> Encode.optional input.second ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ) ]


buildAddTensionInput : AddTensionInputRequiredFields -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields) -> AddTensionInput
buildAddTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { message = Absent, receivers = Absent, comments = Absent, labels = Absent, n_comments = Absent }
    in
    AddTensionInput { createdAt = required.createdAt, createdBy = required.createdBy, message = optionals.message, nth = required.nth, title = required.title, type_ = required.type_, emitter = required.emitter, receivers = optionals.receivers, isAnonymous = required.isAnonymous, comments = optionals.comments, labels = optionals.labels, n_comments = optionals.n_comments }


type alias AddTensionInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , nth : Int
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitter : NodeRef
    , isAnonymous : Bool
    }


type alias AddTensionInputOptionalFields =
    { message : OptionalArgument String
    , receivers : OptionalArgument (List NodeRef)
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , createdBy : UserRef
    , message : OptionalArgument String
    , nth : Int
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , emitter : NodeRef
    , receivers : OptionalArgument (List NodeRef)
    , isAnonymous : Bool
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "createdBy", encodeUserRef input.createdBy |> Just ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.int input.nth |> Just ), ( "title", Encode.string input.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input.type_ |> Just ), ( "emitter", encodeNodeRef input.emitter |> Just ), ( "receivers", (encodeNodeRef |> Encode.list) |> Encode.optional input.receivers ), ( "isAnonymous", Encode.bool input.isAnonymous |> Just ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildAddUserInput : AddUserInputRequiredFields -> (AddUserInputOptionalFields -> AddUserInputOptionalFields) -> AddUserInput
buildAddUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { fullname = Absent, roles = Absent, backed_roles = Absent, bio = Absent }
    in
    AddUserInput { createdAt = required.createdAt, username = required.username, fullname = optionals.fullname, password = required.password, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , username : String
    , password : String
    }


type alias AddUserInputOptionalFields =
    { fullname : OptionalArgument String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , username : String
    , fullname : OptionalArgument String
    , password : String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input.createdAt |> Just ), ( "username", Encode.string input.username |> Just ), ( "fullname", Encode.string |> Encode.optional input.fullname ), ( "password", Encode.string input.password |> Just ), ( "roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ) ]


buildCircleFilter : (CircleFilterOptionalFields -> CircleFilterOptionalFields) -> CircleFilter
buildCircleFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, and = Absent, or = Absent, not = Absent }
    in
    CircleFilter { id = optionals.id, createdAt = optionals.createdAt, name = optionals.name, nameid = optionals.nameid, and = optionals.and, or = optionals.or, not = optionals.not }


type alias CircleFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , and : OptionalArgument CircleFilter
    , or : OptionalArgument CircleFilter
    , not : OptionalArgument CircleFilter
    }


{-| Type alias for the `CircleFilter` attributes. Note that this type
needs to use the `CircleFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CircleFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , and : OptionalArgument CircleFilter
    , or : OptionalArgument CircleFilter
    , not : OptionalArgument CircleFilter
    }


{-| Type for the CircleFilter input object.
-}
type CircleFilter
    = CircleFilter CircleFilterRaw


{-| Encode a CircleFilter into a value that can be used as an argument.
-}
encodeCircleFilter : CircleFilter -> Value
encodeCircleFilter (CircleFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter |> Encode.optional input.nameid ), ( "and", encodeCircleFilter |> Encode.optional input.and ), ( "or", encodeCircleFilter |> Encode.optional input.or ), ( "not", encodeCircleFilter |> Encode.optional input.not ) ]


buildCircleOrder : (CircleOrderOptionalFields -> CircleOrderOptionalFields) -> CircleOrder
buildCircleOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CircleOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias CircleOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CircleOrderable.CircleOrderable
    , desc : OptionalArgument Fractal.Enum.CircleOrderable.CircleOrderable
    , then_ : OptionalArgument CircleOrder
    }


{-| Type alias for the `CircleOrder` attributes. Note that this type
needs to use the `CircleOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CircleOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CircleOrderable.CircleOrderable
    , desc : OptionalArgument Fractal.Enum.CircleOrderable.CircleOrderable
    , then_ : OptionalArgument CircleOrder
    }


{-| Type for the CircleOrder input object.
-}
type CircleOrder
    = CircleOrder CircleOrderRaw


{-| Encode a CircleOrder into a value that can be used as an argument.
-}
encodeCircleOrder : CircleOrder -> Value
encodeCircleOrder (CircleOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CircleOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.CircleOrderable.toString |> Encode.optional input.desc ), ( "then", encodeCircleOrder |> Encode.optional input.then_ ) ]


buildCirclePatch : (CirclePatchOptionalFields -> CirclePatchOptionalFields) -> CirclePatch
buildCirclePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, name = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent, isRoot = Absent }
    in
    CirclePatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, name = optionals.name, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, isRoot = optionals.isRoot }


type alias CirclePatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , isRoot : OptionalArgument Bool
    }


{-| Type alias for the `CirclePatch` attributes. Note that this type
needs to use the `CirclePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CirclePatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , isRoot : OptionalArgument Bool
    }


{-| Type for the CirclePatch input object.
-}
type CirclePatch
    = CirclePatch CirclePatchRaw


{-| Encode a CirclePatch into a value that can be used as an argument.
-}
encodeCirclePatch : CirclePatch -> Value
encodeCirclePatch (CirclePatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string |> Encode.optional input.name ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ) ]


buildCircleRef : (CircleRefOptionalFields -> CircleRefOptionalFields) -> CircleRef
buildCircleRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, name = Absent, nameid = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent, isRoot = Absent }
    in
    CircleRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, name = optionals.name, nameid = optionals.nameid, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, isRoot = optionals.isRoot }


type alias CircleRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , isRoot : OptionalArgument Bool
    }


{-| Type alias for the `CircleRef` attributes. Note that this type
needs to use the `CircleRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CircleRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , isRoot : OptionalArgument Bool
    }


{-| Type for the CircleRef input object.
-}
type CircleRef
    = CircleRef CircleRefRaw


{-| Encode a CircleRef into a value that can be used as an argument.
-}
encodeCircleRef : CircleRef -> Value
encodeCircleRef (CircleRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "isRoot", Encode.bool |> Encode.optional input.isRoot ) ]


buildCommentFilter : (CommentFilterOptionalFields -> CommentFilterOptionalFields) -> CommentFilter
buildCommentFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument CommentFilter
    , or : OptionalArgument CommentFilter
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodeCommentFilter |> Encode.optional input.and ), ( "or", encodeCommentFilter |> Encode.optional input.or ), ( "not", encodeCommentFilter |> Encode.optional input.not ) ]


buildCommentOrder : (CommentOrderOptionalFields -> CommentOrderOptionalFields) -> CommentOrder
buildCommentOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input.desc ), ( "then", encodeCommentOrder |> Encode.optional input.then_ ) ]


buildCommentPatch : (CommentPatchOptionalFields -> CommentPatchOptionalFields) -> CommentPatch
buildCommentPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent, void_ = Absent }
    in
    CommentPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias CommentPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildCommentRef : (CommentRefOptionalFields -> CommentRefOptionalFields) -> CommentRef
buildCommentRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, message = Absent, void_ = Absent }
    in
    CommentRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, void_ = optionals.void_ }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "_VOID", Encode.string |> Encode.optional input.void_ ) ]


buildDateTimeFilter : (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields) -> DateTimeFilter
buildDateTimeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.eq ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.gt ) ]


buildFloatFilter : (FloatFilterOptionalFields -> FloatFilterOptionalFields) -> FloatFilter
buildFloatFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input.eq ), ( "le", Encode.float |> Encode.optional input.le ), ( "lt", Encode.float |> Encode.optional input.lt ), ( "ge", Encode.float |> Encode.optional input.ge ), ( "gt", Encode.float |> Encode.optional input.gt ) ]


buildIntFilter : (IntFilterOptionalFields -> IntFilterOptionalFields) -> IntFilter
buildIntFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input.eq ), ( "le", Encode.int |> Encode.optional input.le ), ( "lt", Encode.int |> Encode.optional input.lt ), ( "ge", Encode.int |> Encode.optional input.ge ), ( "gt", Encode.int |> Encode.optional input.gt ) ]


buildLabelFilter : (LabelFilterOptionalFields -> LabelFilterOptionalFields) -> LabelFilter
buildLabelFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals.id, name = optionals.name, and = optionals.and, or = optionals.or, not = optionals.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , and : OptionalArgument LabelFilter
    , or : OptionalArgument LabelFilter
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "name", encodeStringHashFilter |> Encode.optional input.name ), ( "and", encodeLabelFilter |> Encode.optional input.and ), ( "or", encodeLabelFilter |> Encode.optional input.or ), ( "not", encodeLabelFilter |> Encode.optional input.not ) ]


buildLabelOrder : (LabelOrderOptionalFields -> LabelOrderOptionalFields) -> LabelOrder
buildLabelOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input.desc ), ( "then", encodeLabelOrder |> Encode.optional input.then_ ) ]


buildLabelRef : (LabelRefOptionalFields -> LabelRefOptionalFields) -> LabelRef
buildLabelRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-| Type for the LabelRef input object.
-}
type alias LabelRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    }


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildMandateFilter : (MandateFilterOptionalFields -> MandateFilterOptionalFields) -> MandateFilter
buildMandateFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, purpose = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, purpose = optionals.purpose, and = optionals.and, or = optionals.or, not = optionals.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , purpose : OptionalArgument StringFullTextFilter
    , and : OptionalArgument MandateFilter
    , or : OptionalArgument MandateFilter
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input.purpose ), ( "and", encodeMandateFilter |> Encode.optional input.and ), ( "or", encodeMandateFilter |> Encode.optional input.or ), ( "not", encodeMandateFilter |> Encode.optional input.not ) ]


buildMandateOrder : (MandateOrderOptionalFields -> MandateOrderOptionalFields) -> MandateOrder
buildMandateOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input.desc ), ( "then", encodeMandateOrder |> Encode.optional input.then_ ) ]


buildMandatePatch : (MandatePatchOptionalFields -> MandatePatchOptionalFields) -> MandatePatch
buildMandatePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent, purpose = Absent, responsabilities = Absent, domains = Absent }
    in
    MandatePatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains }


type alias MandatePatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type alias for the `MandatePatch` attributes. Note that this type
needs to use the `MandatePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandatePatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type for the MandatePatch input object.
-}
type MandatePatch
    = MandatePatch MandatePatchRaw


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch (MandatePatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", (Encode.string |> Encode.list) |> Encode.optional input.domains ) ]


buildMandateRef : (MandateRefOptionalFields -> MandateRefOptionalFields) -> MandateRef
buildMandateRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, message = Absent, purpose = Absent, responsabilities = Absent, domains = Absent }
    in
    MandateRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, purpose = optionals.purpose, responsabilities = optionals.responsabilities, domains = optionals.domains }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type alias for the `MandateRef` attributes. Note that this type
needs to use the `MandateRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument (List String)
    }


{-| Type for the MandateRef input object.
-}
type MandateRef
    = MandateRef MandateRefRaw


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef (MandateRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "purpose", Encode.string |> Encode.optional input.purpose ), ( "responsabilities", Encode.string |> Encode.optional input.responsabilities ), ( "domains", (Encode.string |> Encode.list) |> Encode.optional input.domains ) ]


buildNodeFilter : (NodeFilterOptionalFields -> NodeFilterOptionalFields) -> NodeFilter
buildNodeFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals.id, createdAt = optionals.createdAt, name = optionals.name, nameid = optionals.nameid, and = optionals.and, or = optionals.or, not = optionals.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , and : OptionalArgument NodeFilter
    , or : OptionalArgument NodeFilter
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter |> Encode.optional input.nameid ), ( "and", encodeNodeFilter |> Encode.optional input.and ), ( "or", encodeNodeFilter |> Encode.optional input.or ), ( "not", encodeNodeFilter |> Encode.optional input.not ) ]


buildNodeOrder : (NodeOrderOptionalFields -> NodeOrderOptionalFields) -> NodeOrder
buildNodeOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input.desc ), ( "then", encodeNodeOrder |> Encode.optional input.then_ ) ]


buildNodePatch : (NodePatchOptionalFields -> NodePatchOptionalFields) -> NodePatch
buildNodePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, name = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent }
    in
    NodePatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, name = optionals.name, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in }


type alias NodePatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string |> Encode.optional input.name ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ) ]


buildNodeRef : (NodeRefOptionalFields -> NodeRefOptionalFields) -> NodeRef
buildNodeRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, nameid = Absent }
    in
    { id = optionals.id, nameid = optionals.nameid }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    }


{-| Type for the NodeRef input object.
-}
type alias NodeRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    }


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "nameid", Encode.string |> Encode.optional input.nameid ) ]


buildPostFilter : (PostFilterOptionalFields -> PostFilterOptionalFields) -> PostFilter
buildPostFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, and = optionals.and, or = optionals.or, not = optionals.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , and : OptionalArgument PostFilter
    , or : OptionalArgument PostFilter
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "and", encodePostFilter |> Encode.optional input.and ), ( "or", encodePostFilter |> Encode.optional input.or ), ( "not", encodePostFilter |> Encode.optional input.not ) ]


buildPostOrder : (PostOrderOptionalFields -> PostOrderOptionalFields) -> PostOrder
buildPostOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input.desc ), ( "then", encodePostOrder |> Encode.optional input.then_ ) ]


buildPostPatch : (PostPatchOptionalFields -> PostPatchOptionalFields) -> PostPatch
buildPostPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent }
    in
    PostPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message }


type alias PostPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ) ]


buildPostRef : PostRefRequiredFields -> PostRef
buildPostRef required =
    { id = required.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input.id |> Just ) ]


buildRoleFilter : (RoleFilterOptionalFields -> RoleFilterOptionalFields) -> RoleFilter
buildRoleFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, skills = Absent, and = Absent, or = Absent, not = Absent }
    in
    RoleFilter { id = optionals.id, createdAt = optionals.createdAt, name = optionals.name, nameid = optionals.nameid, skills = optionals.skills, and = optionals.and, or = optionals.or, not = optionals.not }


type alias RoleFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , skills : OptionalArgument StringTermFilter
    , and : OptionalArgument RoleFilter
    , or : OptionalArgument RoleFilter
    , not : OptionalArgument RoleFilter
    }


{-| Type alias for the `RoleFilter` attributes. Note that this type
needs to use the `RoleFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter
    , skills : OptionalArgument StringTermFilter
    , and : OptionalArgument RoleFilter
    , or : OptionalArgument RoleFilter
    , not : OptionalArgument RoleFilter
    }


{-| Type for the RoleFilter input object.
-}
type RoleFilter
    = RoleFilter RoleFilterRaw


{-| Encode a RoleFilter into a value that can be used as an argument.
-}
encodeRoleFilter : RoleFilter -> Value
encodeRoleFilter (RoleFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input.name ), ( "nameid", encodeStringHashFilter |> Encode.optional input.nameid ), ( "skills", encodeStringTermFilter |> Encode.optional input.skills ), ( "and", encodeRoleFilter |> Encode.optional input.and ), ( "or", encodeRoleFilter |> Encode.optional input.or ), ( "not", encodeRoleFilter |> Encode.optional input.not ) ]


buildRoleOrder : (RoleOrderOptionalFields -> RoleOrderOptionalFields) -> RoleOrder
buildRoleOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    RoleOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias RoleOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.RoleOrderable.RoleOrderable
    , desc : OptionalArgument Fractal.Enum.RoleOrderable.RoleOrderable
    , then_ : OptionalArgument RoleOrder
    }


{-| Type alias for the `RoleOrder` attributes. Note that this type
needs to use the `RoleOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleOrderRaw =
    { asc : OptionalArgument Fractal.Enum.RoleOrderable.RoleOrderable
    , desc : OptionalArgument Fractal.Enum.RoleOrderable.RoleOrderable
    , then_ : OptionalArgument RoleOrder
    }


{-| Type for the RoleOrder input object.
-}
type RoleOrder
    = RoleOrder RoleOrderRaw


{-| Encode a RoleOrder into a value that can be used as an argument.
-}
encodeRoleOrder : RoleOrder -> Value
encodeRoleOrder (RoleOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.RoleOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.RoleOrderable.toString |> Encode.optional input.desc ), ( "then", encodeRoleOrder |> Encode.optional input.then_ ) ]


buildRolePatch : (RolePatchOptionalFields -> RolePatchOptionalFields) -> RolePatch
buildRolePatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, name = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent, user = Absent, second = Absent, skills = Absent }
    in
    RolePatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, name = optionals.name, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, user = optionals.user, second = optionals.second, skills = optionals.skills }


type alias RolePatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type alias for the `RolePatch` attributes. Note that this type
needs to use the `RolePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RolePatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type for the RolePatch input object.
-}
type RolePatch
    = RolePatch RolePatchRaw


{-| Encode a RolePatch into a value that can be used as an argument.
-}
encodeRolePatch : RolePatch -> Value
encodeRolePatch (RolePatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string |> Encode.optional input.name ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "user", encodeUserRef |> Encode.optional input.user ), ( "second", encodeUserRef |> Encode.optional input.second ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ) ]


buildRoleRef : (RoleRefOptionalFields -> RoleRefOptionalFields) -> RoleRef
buildRoleRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, parent = Absent, children = Absent, name = Absent, nameid = Absent, mandate = Absent, tensions_out = Absent, tensions_in = Absent, n_tensions_out = Absent, n_tensions_in = Absent, user = Absent, second = Absent, skills = Absent }
    in
    RoleRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, parent = optionals.parent, children = optionals.children, name = optionals.name, nameid = optionals.nameid, mandate = optionals.mandate, tensions_out = optionals.tensions_out, tensions_in = optionals.tensions_in, n_tensions_out = optionals.n_tensions_out, n_tensions_in = optionals.n_tensions_in, user = optionals.user, second = optionals.second, skills = optionals.skills }


type alias RoleRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type alias for the `RoleRef` attributes. Note that this type
needs to use the `RoleRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , n_tensions_out : OptionalArgument Int
    , n_tensions_in : OptionalArgument Int
    , user : OptionalArgument UserRef
    , second : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    }


{-| Type for the RoleRef input object.
-}
type RoleRef
    = RoleRef RoleRefRaw


{-| Encode a RoleRef into a value that can be used as an argument.
-}
encodeRoleRef : RoleRef -> Value
encodeRoleRef (RoleRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "parent", encodeNodeRef |> Encode.optional input.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input.children ), ( "name", Encode.string |> Encode.optional input.name ), ( "nameid", Encode.string |> Encode.optional input.nameid ), ( "mandate", encodeMandateRef |> Encode.optional input.mandate ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input.tensions_in ), ( "n_tensions_out", Encode.int |> Encode.optional input.n_tensions_out ), ( "n_tensions_in", Encode.int |> Encode.optional input.n_tensions_in ), ( "user", encodeUserRef |> Encode.optional input.user ), ( "second", encodeUserRef |> Encode.optional input.second ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input.skills ) ]


buildStringExactFilter : (StringExactFilterOptionalFields -> StringExactFilterOptionalFields) -> StringExactFilter
buildStringExactFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent }
    in
    { eq = optionals.eq, le = optionals.le, lt = optionals.lt, ge = optionals.ge, gt = optionals.gt }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ), ( "le", Encode.string |> Encode.optional input.le ), ( "lt", Encode.string |> Encode.optional input.lt ), ( "ge", Encode.string |> Encode.optional input.ge ), ( "gt", Encode.string |> Encode.optional input.gt ) ]


buildStringFullTextFilter : (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields) -> StringFullTextFilter
buildStringFullTextFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals.alloftext, anyoftext = optionals.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input.anyoftext ) ]


buildStringHashFilter : (StringHashFilterOptionalFields -> StringHashFilterOptionalFields) -> StringHashFilter
buildStringHashFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { eq = Absent }
    in
    { eq = optionals.eq }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input.eq ) ]


buildStringRegExpFilter : (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields) -> StringRegExpFilter
buildStringRegExpFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { regexp = Absent }
    in
    { regexp = optionals.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input.regexp ) ]


buildStringTermFilter : (StringTermFilterOptionalFields -> StringTermFilterOptionalFields) -> StringTermFilter
buildStringTermFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals.allofterms, anyofterms = optionals.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input.anyofterms ) ]


buildTensionFilter : (TensionFilterOptionalFields -> TensionFilterOptionalFields) -> TensionFilter
buildTensionFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, message = Absent, title = Absent, type_ = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals.id, createdAt = optionals.createdAt, message = optionals.message, title = optionals.title, type_ = optionals.type_, and = optionals.and, or = optionals.or, not = optionals.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , title : OptionalArgument StringTermFilter
    , type_ : OptionalArgument TensionType_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , title : OptionalArgument StringTermFilter
    , type_ : OptionalArgument TensionType_hash
    , and : OptionalArgument TensionFilter
    , or : OptionalArgument TensionFilter
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input.message ), ( "title", encodeStringTermFilter |> Encode.optional input.title ), ( "type_", encodeTensionType_hash |> Encode.optional input.type_ ), ( "and", encodeTensionFilter |> Encode.optional input.and ), ( "or", encodeTensionFilter |> Encode.optional input.or ), ( "not", encodeTensionFilter |> Encode.optional input.not ) ]


buildTensionOrder : (TensionOrderOptionalFields -> TensionOrderOptionalFields) -> TensionOrder
buildTensionOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input.desc ), ( "then", encodeTensionOrder |> Encode.optional input.then_ ) ]


buildTensionPatch : (TensionPatchOptionalFields -> TensionPatchOptionalFields) -> TensionPatch
buildTensionPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, createdBy = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitter = Absent, receivers = Absent, isAnonymous = Absent, comments = Absent, labels = Absent, n_comments = Absent }
    in
    TensionPatch { createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitter = optionals.emitter, receivers = optionals.receivers, isAnonymous = optionals.isAnonymous, comments = optionals.comments, labels = optionals.labels, n_comments = optionals.n_comments }


type alias TensionPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument Int
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , receivers : OptionalArgument (List NodeRef)
    , isAnonymous : OptionalArgument Bool
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument Int
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , receivers : OptionalArgument (List NodeRef)
    , isAnonymous : OptionalArgument Bool
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.int |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receivers", (encodeNodeRef |> Encode.list) |> Encode.optional input.receivers ), ( "isAnonymous", Encode.bool |> Encode.optional input.isAnonymous ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildTensionRef : (TensionRefOptionalFields -> TensionRefOptionalFields) -> TensionRef
buildTensionRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, createdBy = Absent, message = Absent, nth = Absent, title = Absent, type_ = Absent, emitter = Absent, receivers = Absent, isAnonymous = Absent, comments = Absent, labels = Absent, n_comments = Absent }
    in
    TensionRef { id = optionals.id, createdAt = optionals.createdAt, createdBy = optionals.createdBy, message = optionals.message, nth = optionals.nth, title = optionals.title, type_ = optionals.type_, emitter = optionals.emitter, receivers = optionals.receivers, isAnonymous = optionals.isAnonymous, comments = optionals.comments, labels = optionals.labels, n_comments = optionals.n_comments }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument Int
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , receivers : OptionalArgument (List NodeRef)
    , isAnonymous : OptionalArgument Bool
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , createdBy : OptionalArgument UserRef
    , message : OptionalArgument String
    , nth : OptionalArgument Int
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , emitter : OptionalArgument NodeRef
    , receivers : OptionalArgument (List NodeRef)
    , isAnonymous : OptionalArgument Bool
    , comments : OptionalArgument (List CommentRef)
    , labels : OptionalArgument (List LabelRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "createdBy", encodeUserRef |> Encode.optional input.createdBy ), ( "message", Encode.string |> Encode.optional input.message ), ( "nth", Encode.int |> Encode.optional input.nth ), ( "title", Encode.string |> Encode.optional input.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input.type_ ), ( "emitter", encodeNodeRef |> Encode.optional input.emitter ), ( "receivers", (encodeNodeRef |> Encode.list) |> Encode.optional input.receivers ), ( "isAnonymous", Encode.bool |> Encode.optional input.isAnonymous ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input.comments ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input.labels ), ( "n_comments", Encode.int |> Encode.optional input.n_comments ) ]


buildTensionType_hash : TensionType_hashRequiredFields -> TensionType_hash
buildTensionType_hash required =
    { eq = required.eq }


type alias TensionType_hashRequiredFields =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : Fractal.Enum.TensionType.TensionType }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString input.eq |> Just ) ]


buildUpdateCircleInput : UpdateCircleInputRequiredFields -> (UpdateCircleInputOptionalFields -> UpdateCircleInputOptionalFields) -> UpdateCircleInput
buildUpdateCircleInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateCircleInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateCircleInputRequiredFields =
    { filter : CircleFilter }


type alias UpdateCircleInputOptionalFields =
    { set : OptionalArgument CirclePatch
    , remove : OptionalArgument CirclePatch
    }


{-| Type alias for the `UpdateCircleInput` attributes. Note that this type
needs to use the `UpdateCircleInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCircleInputRaw =
    { filter : CircleFilter
    , set : OptionalArgument CirclePatch
    , remove : OptionalArgument CirclePatch
    }


{-| Type for the UpdateCircleInput input object.
-}
type UpdateCircleInput
    = UpdateCircleInput UpdateCircleInputRaw


{-| Encode a UpdateCircleInput into a value that can be used as an argument.
-}
encodeUpdateCircleInput : UpdateCircleInput -> Value
encodeUpdateCircleInput (UpdateCircleInput input) =
    Encode.maybeObject
        [ ( "filter", encodeCircleFilter input.filter |> Just ), ( "set", encodeCirclePatch |> Encode.optional input.set ), ( "remove", encodeCirclePatch |> Encode.optional input.remove ) ]


buildUpdateCommentInput : UpdateCommentInputRequiredFields -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields) -> UpdateCommentInput
buildUpdateCommentInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input.set ), ( "remove", encodeCommentPatch |> Encode.optional input.remove ) ]


buildUpdateMandateInput : UpdateMandateInputRequiredFields -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields) -> UpdateMandateInput
buildUpdateMandateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input.set ), ( "remove", encodeMandatePatch |> Encode.optional input.remove ) ]


buildUpdateNodeInput : UpdateNodeInputRequiredFields -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields) -> UpdateNodeInput
buildUpdateNodeInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input.set ), ( "remove", encodeNodePatch |> Encode.optional input.remove ) ]


buildUpdatePostInput : UpdatePostInputRequiredFields -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields) -> UpdatePostInput
buildUpdatePostInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input.set ), ( "remove", encodePostPatch |> Encode.optional input.remove ) ]


buildUpdateRoleInput : UpdateRoleInputRequiredFields -> (UpdateRoleInputOptionalFields -> UpdateRoleInputOptionalFields) -> UpdateRoleInput
buildUpdateRoleInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateRoleInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateRoleInputRequiredFields =
    { filter : RoleFilter }


type alias UpdateRoleInputOptionalFields =
    { set : OptionalArgument RolePatch
    , remove : OptionalArgument RolePatch
    }


{-| Type alias for the `UpdateRoleInput` attributes. Note that this type
needs to use the `UpdateRoleInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateRoleInputRaw =
    { filter : RoleFilter
    , set : OptionalArgument RolePatch
    , remove : OptionalArgument RolePatch
    }


{-| Type for the UpdateRoleInput input object.
-}
type UpdateRoleInput
    = UpdateRoleInput UpdateRoleInputRaw


{-| Encode a UpdateRoleInput into a value that can be used as an argument.
-}
encodeUpdateRoleInput : UpdateRoleInput -> Value
encodeUpdateRoleInput (UpdateRoleInput input) =
    Encode.maybeObject
        [ ( "filter", encodeRoleFilter input.filter |> Just ), ( "set", encodeRolePatch |> Encode.optional input.set ), ( "remove", encodeRolePatch |> Encode.optional input.remove ) ]


buildUpdateTensionInput : UpdateTensionInputRequiredFields -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields) -> UpdateTensionInput
buildUpdateTensionInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input.set ), ( "remove", encodeTensionPatch |> Encode.optional input.remove ) ]


buildUpdateUserInput : UpdateUserInputRequiredFields -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields) -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required.filter, set = optionals.set, remove = optionals.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input.set ), ( "remove", encodeUserPatch |> Encode.optional input.remove ) ]


buildUserFilter : (UserFilterOptionalFields -> UserFilterOptionalFields) -> UserFilter
buildUserFilter fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, username = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals.id, createdAt = optionals.createdAt, username = optionals.username, and = optionals.and, or = optionals.or, not = optionals.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , username : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , username : OptionalArgument StringHashFilter
    , and : OptionalArgument UserFilter
    , or : OptionalArgument UserFilter
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input.createdAt ), ( "username", encodeStringHashFilter |> Encode.optional input.username ), ( "and", encodeUserFilter |> Encode.optional input.and ), ( "or", encodeUserFilter |> Encode.optional input.or ), ( "not", encodeUserFilter |> Encode.optional input.not ) ]


buildUserOrder : (UserOrderOptionalFields -> UserOrderOptionalFields) -> UserOrder
buildUserOrder fillOptionals =
    let
        optionals =
            fillOptionals
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals.asc, desc = optionals.desc, then_ = optionals.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input.desc ), ( "then", encodeUserOrder |> Encode.optional input.then_ ) ]


buildUserPatch : (UserPatchOptionalFields -> UserPatchOptionalFields) -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { createdAt = Absent, fullname = Absent, password = Absent, roles = Absent, backed_roles = Absent, bio = Absent }
    in
    UserPatch { createdAt = optionals.createdAt, fullname = optionals.fullname, password = optionals.password, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , fullname : OptionalArgument String
    , password : OptionalArgument String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , fullname : OptionalArgument String
    , password : OptionalArgument String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "fullname", Encode.string |> Encode.optional input.fullname ), ( "password", Encode.string |> Encode.optional input.password ), ( "roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ) ]


buildUserRef : (UserRefOptionalFields -> UserRefOptionalFields) -> UserRef
buildUserRef fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, createdAt = Absent, username = Absent, fullname = Absent, password = Absent, roles = Absent, backed_roles = Absent, bio = Absent }
    in
    UserRef { id = optionals.id, createdAt = optionals.createdAt, username = optionals.username, fullname = optionals.fullname, password = optionals.password, roles = optionals.roles, backed_roles = optionals.backed_roles, bio = optionals.bio }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , fullname : OptionalArgument String
    , password : OptionalArgument String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , fullname : OptionalArgument String
    , password : OptionalArgument String
    , roles : OptionalArgument (List RoleRef)
    , backed_roles : OptionalArgument (List RoleRef)
    , bio : OptionalArgument String
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input.createdAt ), ( "username", Encode.string |> Encode.optional input.username ), ( "fullname", Encode.string |> Encode.optional input.fullname ), ( "password", Encode.string |> Encode.optional input.password ), ( "roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.roles ), ( "backed_roles", (encodeRoleRef |> Encode.list) |> Encode.optional input.backed_roles ), ( "bio", Encode.string |> Encode.optional input.bio ) ]
